cimport numpy

from libc.math cimport sqrt
import cython

#A constant to refer to the value we use to encode land
cdef int LAND = 1

class NotAtSea(Exception): pass
@cython.boundscheck(False)
def cast_ray(origin, direction, float d_max, numpy.ndarray[numpy.int_t, ndim=2] land_mask_array):
    """ March from the origin towards a direction until either land or a
    maximum distance is met.
    
        origin - a 2 element list indicating the i,j origin in 
            land_mask_array index coordinates
        direction - a 2 element numpy array indicating the  marching direction
            in terms of pixel distances
        d_max - a float to determin the maximum distance to traverse in terms of 
            pixel units, should be > 1.0 units
        land_mask_array - a two dimensional numpy array with values either 0 or 1 indicating
            1 as a land point and 0 as a sea point
        
        Returns the distance to the origin."""


    #Break into components for easy c conversion

    #Normalize direction so that the largest component is one pixel big
    cdef float unit_stepi = direction[0] / <float>(abs(max(direction)))
    cdef float unit_stepj = direction[1] / <float>(abs(max(direction)))

    # Initialize the origin, step and path, break in components for c
    cdef int origini = origin[0]
    cdef int originj = origin[1]

    #Keep track of number of pixels walked
    cdef int steps = 0

    #These will keep track of the current position
    cdef int posi = origini
    cdef int posj = originj

    # Not on sea, no fetch
    if land_mask_array[posi, posj] == LAND:
        raise NotAtSea('Not at sea, no fetch')
    #These will be temporary placeholders for distance calculations below
    cdef float i_dist
    cdef float j_dist

    while True:
        posi = <int>(origini + unit_stepi * steps)
        posj = <int>(originj + unit_stepj * steps)

        #see if we walk off the edge of the land_mask_array
        if posi < 0 or posi >= land_mask_array.shape[0] or posj < 0 or \
                posj >= land_mask_array.shape[1]:
            break

        #see if we hit land
        if land_mask_array[posi, posj] == LAND:
            break

        #See if we've traveled beyond d_max
        i_dist = posi-origini
        j_dist = posj-originj
        if sqrt(i_dist * i_dist + j_dist * j_dist) > d_max:
            return d_max

        #Take the next step
        steps += 1

    #Step one back because we hit a land pixel, or walked off the edge
    steps -= 1
    posi = <int>(origini + unit_stepi * steps)
    posj = <int>(originj + unit_stepj * steps)
    i_dist = posi-origini
    j_dist = posj-originj
    return sqrt(i_dist * i_dist + j_dist * j_dist)
