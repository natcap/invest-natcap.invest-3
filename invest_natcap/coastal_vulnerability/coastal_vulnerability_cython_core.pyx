import numpy
cimport numpy

class NotAtSea(Exception): pass

def cast_ray(origin, direction, float d_max, numpy.ndarray[numpy.int_t, ndim=2] raster):
    """ March from the origin towards a direction until either land or a
    maximum distance is met.
    
        origin - a 2 element list indicating the i,j origin in 
            raster index coordinates
        direction - a 2 element numpy array indicating the  marching direction
            in terms of pixel distances
        d_max - a float to determin the maximum distance to traverse in terms of 
            pixel units
        raster - a two dimensional numpy array with values either 0 or 1 indicating
            1 as a land point and 0 as a sea point
        
        Returns the distance to the origin."""
    # Initialize the origin, step and path
    cdef numpy.ndarray[numpy.float_t, ndim=1] numpy_origin = numpy.around(numpy.array(list(origin), dtype=numpy.float))

    cdef int origini = origin[0]
    cdef int originj = origin[1]

    cdef numpy.ndarray[numpy.float_t, ndim=1] numpy_direction = numpy.array(direction, dtype=numpy.float)


    #This normalizes the step so we're guaranteed to traverse at least
    #one pixel per step
    unit_step = numpy_direction / numpy.fabs(numpy_direction, dtype=numpy.float).max()
    cdef float unit_stepi = unit_step[0]
    cdef float unit_stepj = unit_step[1]

    cdef int steps = 0

    cdef int posi = origini
    cdef float posj = originj

    cdef numpy.ndarray[numpy.float_t, ndim=1] pos = numpy_origin.copy()

    # Not on sea, no fetch
    if raster[posi,posj] != 0:
        raise NotAtSea('Not at sea, no fetch')

    # Short distance, no fetch
    if d_max < 1.0:
        return 0.0

    # Preliminary checks
    assert raster.size > 1      # More than 1 point
    assert(numpy.fabs(numpy_direction).max() > 0) # Non-zero vector
    # Step until we can't, then backtrack once

    cdef int LAND = 1


    while True:
        posi = int(origini + unit_stepi * steps)
        posj = int(originj + unit_stepj * steps)

        #pos = numpy_origin + unit_step * steps
        print posi, posj
        #if it's not a valid index, break
        if posi < 0 or posi >= raster.shape[0] or posj < 0 or posj >= raster.shape[1]:
            break

        #if it's not sea, break
        if raster[posi][posj] == LAND:
            break

        #If the pathlength is too long
        if abs(((posi-origini)**2+(posj-originj)**2)**0.5-d_max) < 0.0001:
            break

        steps += 1

    #Step one back because we hit a land pixel
    pos = numpy_origin + unit_step * (steps-1)
    return numpy.sqrt(numpy.sum(numpy.square(pos-numpy_origin)))
