import numpy

class NotAtSea(Exception): pass

def small_distance(path, d_max):
    """ Determines if the path is within the threshold minus an epsilon.
    
        Inputs:
        - path: coordinates used to compute the distance.
        - d_max: distance threshold.
        
        Returns False if pathlength is clearly above the distance threshold 
        (up to an epsilon)."""
    return (numpy.sqrt(numpy.sum(numpy.square(path))) <(d_max+0.0001))

def sea():
    """ Return the code for a sea cell """
    return 0

def is_sea(position, raster):
    """ Determine whether the cell is at sea or not.

        - position: current cell position
        - raster: array used to determine the cell value
                
        Returns True if the cell is at sea, False otrherwise."""
    return (raster[position[0], position[1]] == sea())

def should_step(origin, path, d_max, raster):
    """ Returns true if the cast_ray algorithm should continue stepping.
    
        Inputs:
        - origin, path: coordinates used to get the raster position
        - d_max: maximum fetch distance
        - raster: geographic data to work with
        
        Returns True if cell is sea, within maximum fetch distance, 
        and within raster boundaries. """
    sea = False
    valid_index = (min(numpy.around(origin + path)) >= 0)
    try:
        sea = is_sea(numpy.around(origin + path), raster)
    except:
        return False

    return valid_index and sea and small_distance(path, d_max)

def cast_ray(origin, direction, d_max, raster):
    """ March from the origin towards a direction until either land or a
    maximum distance is met.
    
        origin - a 2 element list indicating the i,j origin in 
            raster index coordinates
        direction - a 2 element numpy array indicating the  marching direction
            in terms of pixel distances
        d_max - a float to determin the maximum distance to traverse in terms of 
            pixel units
        raster - a two dimensional numpy array with values either 0 or 1 indicating
            1 as a land point and 0 as a sea point
        
        Returns the distance to the origin."""
    # Initialize the origin, step and path
    O = numpy.around(numpy.array(list(origin)))
    unit_step = direction / numpy.fabs(direction).max()
    path = numpy.array([0., 0.])
    # Not on sea, no fetch
    if not is_sea(origin, raster):
        raise NotAtSea('Not at sea, no fetch')
    # Short distance, no fetch
    if (d_max < 1.0):
        return 0.0
    # Preliminary checks
    assert raster.size > 1      # More than 1 point
    assert(numpy.fabs(direction).max() > 0) # Non-zero vector
    # Step until we can't, then backtrack once

    while True:
        #if it's not a valid index, break
        if min(numpy.around(origin + path)) < 0:
            break

        #if it's not sea, break
        if not is_sea(numpy.around(origin + path), raster):
            break

        #If the pathlength is too long
        if abs(numpy.sqrt(numpy.sum(numpy.square(path)))-d_max) < 0.0001:
            break

        path += unit_step
    path -= unit_step

    return numpy.sqrt(numpy.sum(numpy.square(path)))
