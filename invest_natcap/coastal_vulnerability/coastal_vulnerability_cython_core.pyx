import numpy

class NotAtSea(Exception): pass

def small_distance(path, d_max):
    """ Determines if the path is within the threshold minus an epsilon.
    
        Inputs:
        - path: coordinates used to compute the distance.
        - d_max: distance threshold.
        
        Returns False if pathlength is clearly above the distance threshold 
        (up to an epsilon)."""
    return (numpy.sqrt(numpy.sum(numpy.square(path))) <(d_max+0.0001))

def sea():
    """ Return the code for a sea cell """
    return 0

def is_sea(position, raster):
    """ Determine whether the cell is at sea or not.

        - position: current cell position
        - raster: array used to determine the cell value
                
        Returns True if the cell is at sea, False otrherwise."""
    return (raster[position[0], position[1]] == sea())

def should_step(origin, path, d_max, raster):
    """ Returns true if the cast_ray algorithm should continue stepping.
    
        Inputs:
        - origin, path: coordinates used to get the raster position
        - d_max: maximum fetch distance
        - raster: geographic data to work with
        
        Returns True if cell is sea, within maximum fetch distance, 
        and within raster boundaries. """
    sea = False
    valid_index = (min(numpy.around(origin + path)) >= 0)
    try:
        sea = is_sea(numpy.around(origin + path), raster)
    except:
        return False

    return valid_index and sea and small_distance(path, d_max)

def cast_ray(origin, direction, d_max, raster):
    """ March from the origin towards a direction until either land or a
    maximum distance is met.
    
        origin - a 2 element list indicating the i,j origin in 
            raster index coordinates
        direction - a 2 element numpy array indicating the  marching direction
            in terms of pixel distances
        d_max - a float to determin the maximum distance to traverse in terms of 
            pixel units
        raster - a two dimensional numpy array with values either 0 or 1 indicating
            1 as a land point and 0 as a sea point
        
        Returns the distance to the origin."""
    # Initialize the origin, step and path
    origin = numpy.around(numpy.array(list(origin)))

    direction = numpy.array(direction, dtype=numpy.float)


    #This normalizes the step so we're guaranteed to traverse at least
    #one pixel per step
    unit_step = direction / numpy.fabs(direction, dtype=numpy.float).max()

    cdef int steps = 0

    pos = origin.copy()

    # Not on sea, no fetch
    if raster[pos[0],pos[1]] != 0:
        raise NotAtSea('Not at sea, no fetch')

    # Short distance, no fetch
    if d_max < 1.0:
        return 0.0

    # Preliminary checks
    assert raster.size > 1      # More than 1 point
    assert(numpy.fabs(direction).max() > 0) # Non-zero vector
    # Step until we can't, then backtrack once


    while True:
        pos = origin + unit_step * steps
        print pos
        #if it's not a valid index, break
        if pos[0] < 0 or pos[0] >= raster.shape[0] or pos[1] < 0 or pos[1] >= raster.shape[1]:
            break

        #if it's not sea, break
        if raster[pos[0], pos[1]] == 1:
            break

        #If the pathlength is too long
        if abs(numpy.sqrt(numpy.sum(numpy.square(pos-origin)))-d_max) < 0.0001:
            break

        steps += 1

    #Step one back because we hit a land pixel
    pos = origin + unit_step * (steps-1)
    return numpy.sqrt(numpy.sum(numpy.square(pos-origin)))
