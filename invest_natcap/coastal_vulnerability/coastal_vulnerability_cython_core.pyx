import numpy
cimport numpy

class NotAtSea(Exception): pass

def cast_ray(origin, direction, float d_max, numpy.ndarray[numpy.float_t, ndim=2] raster):
    """ March from the origin towards a direction until either land or a
    maximum distance is met.
    
        origin - a 2 element list indicating the i,j origin in 
            raster index coordinates
        direction - a 2 element numpy array indicating the  marching direction
            in terms of pixel distances
        d_max - a float to determin the maximum distance to traverse in terms of 
            pixel units
        raster - a two dimensional numpy array with values either 0 or 1 indicating
            1 as a land point and 0 as a sea point
        
        Returns the distance to the origin."""
    # Initialize the origin, step and path
    cdef numpy.ndarray[numpy.float_t, ndim=2] numpy_origin = numpy.around(numpy.array(list(origin)))

    direction = numpy.array(direction, dtype=numpy.float)


    #This normalizes the step so we're guaranteed to traverse at least
    #one pixel per step
    unit_step = direction / numpy.fabs(direction, dtype=numpy.float).max()

    cdef int steps = 0

    pos = numpy_origin.copy()

    # Not on sea, no fetch
    if raster[pos[0],pos[1]] != 0:
        raise NotAtSea('Not at sea, no fetch')

    # Short distance, no fetch
    if d_max < 1.0:
        return 0.0

    # Preliminary checks
    assert raster.size > 1      # More than 1 point
    assert(numpy.fabs(direction).max() > 0) # Non-zero vector
    # Step until we can't, then backtrack once


    while True:
        pos = numpy_origin + unit_step * steps
        print pos
        #if it's not a valid index, break
        if pos[0] < 0 or pos[0] >= raster.shape[0] or pos[1] < 0 or pos[1] >= raster.shape[1]:
            break

        #if it's not sea, break
        if raster[pos[0], pos[1]] == 1:
            break

        #If the pathlength is too long
        if abs(numpy.sqrt(numpy.sum(numpy.square(pos-numpy_origin)))-d_max) < 0.0001:
            break

        steps += 1

    #Step one back because we hit a land pixel
    pos = numpy_origin + unit_step * (steps-1)
    return numpy.sqrt(numpy.sum(numpy.square(pos-numpy_origin)))
