import numpy
cimport numpy

import cython

#A constant to refer to the value we use to encode land
cdef int LAND = 1

class NotAtSea(Exception): pass
@cython.boundscheck(False)
def cast_ray(origin, direction, float d_max, numpy.ndarray[numpy.int_t, ndim=2] raster):
    """ March from the origin towards a direction until either land or a
    maximum distance is met.
    
        origin - a 2 element list indicating the i,j origin in 
            raster index coordinates
        direction - a 2 element numpy array indicating the  marching direction
            in terms of pixel distances
        d_max - a float to determin the maximum distance to traverse in terms of 
            pixel units, should be > 1.0 units
        raster - a two dimensional numpy array with values either 0 or 1 indicating
            1 as a land point and 0 as a sea point
        
        Returns the distance to the origin."""


    #Break into components for easy c conversion

    #Normalize direction so that the largest component is one pixel big
    cdef float unit_stepi = direction[0] / <float>(abs(max(direction)))
    cdef float unit_stepj = direction[1] / <float>(abs(max(direction)))

    # Initialize the origin, step and path, break in components for c
    cdef int origini = origin[0]
    cdef int originj = origin[1]

    #Keep track of number of pixels walked
    cdef int steps = 0

    #These will keep track of the current position
    cdef int posi = origini
    cdef int posj = originj

    # Not on sea, no fetch
    if raster[posi, posj] != 0:
        raise NotAtSea('Not at sea, no fetch')

    while True:
        posi = <int>(origini + unit_stepi * steps)
        posj = <int>(originj + unit_stepj * steps)

        #see if we walk off the edge of the raster
        if posi < 0 or posi >= raster.shape[0] or posj < 0 or \
                posj >= raster.shape[1]:
            break

        #see if we hit land
        if raster[posi, posj] == LAND:
            break

        #See if we've traveled beyond d_max
        if abs(((posi-origini)**2+(posj-originj)**2)**0.5-d_max) < 0.0001:
            return d_max

        steps += 1

    #Step one back because we hit a land pixel
    steps -= 1
    posi = <int>(origini + unit_stepi * steps)
    posj = <int>(originj + unit_stepj * steps)
    cdef float dist_traveled = ((posi-origini)**2 + (posj-originj)**2)**0.5
    return dist_traveled

