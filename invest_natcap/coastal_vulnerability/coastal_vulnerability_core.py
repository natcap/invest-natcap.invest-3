""" Coastal vulnerability model core functions """
import math
import numpy as np
import scipy as sp

from osgeo import gdal
from osgeo import ogr

import logging
from invest_natcap import raster_utils

class NotAtSea(Exception): 
    """ Exception raised by cast_ray when the point for which to compute the
    fetch is not at sea """
    pass


LOGGER = logging.getLogger('coastal_vulnerability_core')
logging.basicConfig(format='%(asctime)s %(name)-15s %(levelname)-8s \
    %(message)s', level=logging.DEBUG, datefmt='%m/%d/%Y %H:%M:%S ')

def sea():
    """ Return the code for a sea cell """
    return 0

def land():
    """ Return the code for a land cell """
    return 1

def nodata():
    """ Return the code for a nodata cell """
    return -1

def shore():
    """ Return the code for a shore cell """
    return 1

def is_sea(position, raster):
    """ Return True if the cell is sea (code 0), False otherwise 

        Inputs: - current cell position
                - raster where the cell value is stored 
                
        Output: - True if sea, False otrherwise"""
    return (raster[position[0], position[1]] == sea())

def is_land(position, raster):
    """ Return True if the cell is on land (code 1), False otherwise 

        Inputs: - current cell position
                 - raster where the cell value is stored
                
        Output: - True if sea, False otrherwise"""
    return (raster[position[0], position[1]] == land())

def execute(args):
    """ Entry point for coastal vulnerability core
    
        args['foo'] - actual data structure the way I want them look like


        returns nothing"""

    pass

def compute_vulnerability_index(r_geomorphology, r_relief, r_habitats, r_slr,
                                r_windexposure, r_waveexposure, r_surge):
    """ Main function that computes a coast vulnerability index """
    #vi = count_var = 6

    return math.sqrt(r_geomorphology * r_relief * r_habitats * r_slr *
                     r_windexposure * r_waveexposure * r_surge)

def convert_shape_to_raster(shapefile, aoi, cell_size):
    """ Convert a shapefile to a raster file """
    # Try to open the area of interest:
    try:
        with open(aoi): 
            pass        
    except IOError:
        print("File ", aoi, " doesn't exist...")

    # Try to open the shapefile:
    try:
        with open(shapefile): 
            pass        
    except IOError:
        print("File ", shapefile, " doesn't exist...")

    aoi_datasource = ogr.Open(aoi)
    global_datasource = ogr.Open(shapefile)

    aoi_layer = aoi_datasource.GetLayer(0)
    global_layer = global_datasource.GetLayer(0)

    aoi_raster_filename = 'aoi_raster.tif'
    global_raster_filename = 'global_raster.tif'
    #Creation of the raster itself, into the URI we just named
    aoi_raster = \
        raster_utils.create_raster_from_vector_extents(cell_size, cell_size,
        gdal.GDT_Int32, nodata(), aoi_raster_filename, aoi_datasource)

    global_dataset = raster_utils.new_raster_from_base(aoi_raster, 
        global_raster_filename, 'GTiff', nodata(), gdal.GDT_Int32)

    #global_raster = \
    #    raster_utils.create_raster_from_vector_extents(cell_size, cell_size,
    #    gdal.GDT_Int32, nodata(), global_raster_filename, global_datasource)

    aoi_band, aoi_nodata = \
        raster_utils.extract_band_and_nodata(aoi_raster)

    global_band, global_nodata = \
        raster_utils.extract_band_and_nodata(global_dataset)

    aoi_band.Fill(aoi_nodata)
    gdal.RasterizeLayer(aoi_raster, [1], aoi_layer, burn_values=[1])

    global_band.Fill(global_nodata)
    gdal.RasterizeLayer(global_dataset, [1], global_layer, burn_values=[land()])

    aoi_array = aoi_band.ReadAsArray()
    global_array = global_band.ReadAsArray()

    land_sea_array = np.ones_like(global_array)

    land_sea_array[global_array == global_nodata] = 0
    land_sea_array[aoi_array == aoi_nodata] = nodata()

#    land_sea_filename = 'land_sea_raster.tif'

#    drv = gdal.GetDriverByName("GTiff")
#    ds = drv.Create(land_sea_filename, 
#                    land_sea_array.shape[1],
#                    land_sea_array.shape[0], 
#                    1, gdal.GDT_Float32)

#    land_sea_band = ds.GetRasterBand(1)
#    land_sea_band.SetNoDataValue(nodata())
#    land_sea_band.WriteArray(land_sea_array)

#    ds = None
#    drv = None

    aoi_datasource = None
    global_datasource = None
    
    return land_sea_array

def small_distance(path, d_max):
    """ Return if distance is within a threshold minus an epsilon """
    return (np.sqrt(np.sum(np.square(path))) <(d_max-0.0001))

def cast_ray(origin, direction, d_max, raster):
    """ March from the origin towards a direction until either land or a
    maximum distance is met. Origin s to be on sea.
    
        Inputs: - origin: algorithm's starting point
                - direction: marching direction
                - d_max: maximum distance to traverse
                - raster: land mass raster
        
        Output: - distance to the origin """
    # Requirement: we want the origin to be integer values
    assert(math.ceil(origin[0]) == origin[0])
    assert(math.ceil(origin[1]) == origin[1])

    # Not on sea, no fetch
    if not is_sea(origin, raster): 
        raise NotAtSea('Not at sea, no fetch')

    # No distance, no fetch
    if (d_max < 0.1): 
        return origin

    # Preliminary checks
    assert raster.size > 1      # More than 1 point
    assert(np.fabs(direction).max() > 0)

    unit_step = direction / np.fabs(direction).max()

    # Determine what is the main axis: 0 is 'i', 1 is 'j'
    main_axis = unit_step[1] - unit_step[0] + (unit_step[1] == unit_step[0])   
    main_axis = main_axis/math.fabs(main_axis) 
    main_axis = int((main_axis + 1) / 2)

    path = np.array([0., 0.])

    print("direction:", direction)
    print("unit_step:", unit_step)
    print("path:", path)
    while (is_sea(origin +path, raster)
           and small_distance(path, d_max)):
        path += unit_step
        print("path:", path, "position:", origin + path, "sea", is_sea(origin
        +path, raster), "forward", small_distance(path, d_max))

    # Backtrack 1 step if on land
    if is_land(origin + path, raster): 
        path -= unit_step

    LOGGER.debug("cr_distance: %s" % np.sqrt(np.sum(np.square(path))))
    return np.sqrt(np.sum(np.square(path)))

def detect_shore(raster):
    """ Return the boundary with land from a raster.
    The boundary could be anything between land and any other land code."""
    # Rich's super-short solution, which uses convolution.
    # Works if land is 1, sea is 0, and nodata is -1:
    assert(land()   ==  1)
    assert(sea()    ==  0)
    assert(nodata() == -1)

    kernel = np.array([[-1, -1, -1],
                       [-1,  8, -1],
                       [-1, -1, -1]])

    # Create a mask that will generate the nodata shore artifacts
    aoi = np.ones_like(raster) * sea()
    aoi[raster == nodata()] = nodata()

    negative_borders = (sp.signal.convolve2d(aoi, \
                                            kernel, \
                                            mode='same') <0 ).astype('int')

    shore_filename = 'negative_shore.tif'
    drv = gdal.GetDriverByName("GTiff")
    ds = drv.Create(shore_filename, 
                negative_borders.shape[1],
                negative_borders.shape[0], 
                1, gdal.GDT_Float32)
    shore_band = ds.GetRasterBand(1)
    shore_band.SetNoDataValue(nodata())
    shore_band.WriteArray(negative_borders)
    ds = None
    drv = None

    borders = (sp.signal.convolve2d(raster, \
                                 kernel, \
                                 mode='same') <0 ).astype('int')
    
    shore_filename = 'shore.tif'
    drv = gdal.GetDriverByName("GTiff")
    ds = drv.Create(shore_filename, 
                borders.shape[1],
                borders.shape[0], 
                1, gdal.GDT_Float32)
    shore_band = ds.GetRasterBand(1)
    shore_band.SetNoDataValue(nodata())
    shore_band.WriteArray(borders)
    ds = None
    drv = None

    borders = ((borders - negative_borders) >0 ).astype('int')

    shore_filename = 'shore_difference.tif'
    drv = gdal.GetDriverByName("GTiff")
    ds = drv.Create(shore_filename, 
                borders.shape[1],
                borders.shape[0], 
                1, gdal.GDT_Float32)
    shore_band = ds.GetRasterBand(1)
    shore_band.SetNoDataValue(nodata())
    shore_band.WriteArray(borders)
    ds = None
    drv = None

    return borders
    
def compute_fetch(land_raster, directions, d_max):
    """ Given a land raster, return the fetch distance from a point
    in given directions 
    
        Inputs: - land_raster: raster where land is encoded as 1s, sea as 0s,
                  and cells outside the area of interest as anything 
                  different from 0s or 1s.
                - directions: tuple of angles (in radians) from which the fetch
                  will be computed for each pixel.
                - d_max: maximum distance over which to compute the fetch
                
        
        Output: - dictionary of fetch data where the key is a coordinate tuple,
                  and the value is a tuple (same size as directions) containing 
                  fetch distances for that point.
        
        Summary: """
    # Extract shore from raster
    shore_raster = detect_shore(land_raster)
    shore_points = np.where(shore_raster == shore())
    #shore_points[0] = shore_points[0][0]
    #shore_points[1] = shore_points[1][0]
    shore_points0 = shore_points[0]
    shore_points1 = shore_points[1]
    
    # precompute directions
    direction_vectors = np.empty((len(directions), 2))

    for d in range(len(directions)):
        direction_vectors[d] = (math.cos(directions[d]), math.sin(directions[d]))

    print("fetch directions:", direction_vectors)

    fetch = {}

    #for point in zip(shore_points[0], shore_points[1]):
    for point in zip(shore_points0, shore_points1):
        try:
            fetch[point] = ()
            for direction in direction_vectors:
                d = cast_ray(point, direction, d_max, land_raster)
                #LOGGER.debug('fetch distance: %s' % str(d))
                fetch[point] = fetch[point] + (d,)
        except NotAtSea:
            #LOGGER.debug("point (%i, %i) not at sea" % point[0], point[1])
            del(fetch[point])

    return fetch

