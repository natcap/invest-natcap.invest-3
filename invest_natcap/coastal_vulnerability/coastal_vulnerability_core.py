import math
import numpy as np
import scipy as sp
from operator import mul
from invest_natcap import raster_utils
from osgeo import gdal
from osgeo import ogr
import logging

LOGGER = logging.getLogger('coastal_vulnerability_core')
logging.basicConfig(format='%(asctime)s %(name)-15s %(levelname)-8s \
    %(message)s', level=logging.DEBUG, datefmt='%m/%d/%Y %H:%M:%S ')

def execute(args):
    """ Entry point for coastal vulnerability core
    
        args['foo'] - actual data structure the way I want them look like


        returns nothing"""

    pass

def compute_vulnerability_index(r_geomorphology, r_relief, r_habitats, r_slr,
                                r_windexposure, r_waveexposure, r_surge):

    vi = count_var = 6

    return math.sqrt(r_geomorphology * r_relief * r_habitats * r_slr *
                     r_windexposure * r_waveexposure * r_surge)


def convert_shape_to_raster(args):
    #Essentially turns a shapefile into a grid!
    aoi_features    = args['working_directory'] + args['aoi']
    global_features = args['working_directory'] + args['global_polygon']

    # Try to open the area of interest:
    try:
        with open(aoi_features) as f: pass        
    except IOError as e:
        print("File ", aoi_features, " doesn't exist...")

    # Try to open the area of interest:
    try:
        with open(global_features) as g: pass        
    except IOError as e:
        print("File ", global_features, " doesn't exist...")

    aoi_datasource = ogr.Open(aoi_features)
    global_datasource = ogr.Open(global_features)

    aoi_layer = aoi_datasource.GetLayer(0)
    global_layer = global_datasource.GetLayer(0)

    cell_size =args['cell_size'] 
    aoi_raster_filename = 'aoi_raster.tif'
    global_raster_filename = 'global_raster.tif'
    #Creation of the raster itself, into the URI we just named
    aoi_raster = \
        raster_utils.create_raster_from_vector_extents(cell_size, cell_size,
        gdal.GDT_Int32, -1, aoi_raster_filename, aoi_datasource)

    global_dataset = raster_utils.new_raster_from_base(aoi_raster, 
        global_raster_filename, 'GTiff', -1, gdal.GDT_Int32)

    global_raster = \
        raster_utils.create_raster_from_vector_extents(cell_size, cell_size,
        gdal.GDT_Int32, -1, global_raster_filename, global_datasource)

    aoi_band, aoi_nodata = \
        raster_utils.extract_band_and_nodata(aoi_raster)

    global_band, global_nodata = \
        raster_utils.extract_band_and_nodata(global_dataset)

    aoi_band.Fill(aoi_nodata)
    gdal.RasterizeLayer(aoi_raster, [1], aoi_layer, burn_values=[1])

    global_band.Fill(global_nodata)
    gdal.RasterizeLayer(global_dataset, [1], global_layer, burn_values=[1])

    aoi_array = aoi_band.ReadAsArray()
    global_array = global_band.ReadAsArray()

    land_sea_nodata = -1.0
    land_sea_array = np.ones_like(global_array)

    land_sea_array[global_array == global_nodata] = 0
    land_sea_array[aoi_array == aoi_nodata] = land_sea_nodata

    land_sea_filename = 'land_sea_raster.tif'

    drv = gdal.GetDriverByName("GTiff")
    ds = drv.Create(land_sea_filename, 
                    land_sea_array.shape[1],
                    land_sea_array.shape[0], 
                    1, gdal.GDT_Float32)

    land_sea_band = ds.GetRasterBand(1)
    land_sea_band.SetNoDataValue(land_sea_nodata)
    land_sea_band.WriteArray(land_sea_array)


    
    ds = None
    drv = None

    pass

def is_sea(position, is_land):
    return not is_land(position)

def small_distance(path, d_max):
    return (np.sqrt(np.sum(np.square(path))) <(d_max-0.0001))

def cast_ray(origin, direction, d_max, raster):
    """ Increment origin in discrete steps until eithre land is found, or
    d_max is met"""
    # We want the origin to be integer values (Is it fine to assert this?)
    assert(math.ceil(origin[0]) == origin[0])
    assert(math.ceil(origin[1]) == origin[1])

    if not d_max: 
        return origin

    def set_raster(r):
        def raster_type_evaluator(position):
            return r[position[0], position[1]]
        return raster_type_evaluator

    cell_is_land = set_raster(raster)

    # Should check that raster has more than 1 point,
    # and that it contains at least 1 shore cell (one 0 and one 1)
    assert raster.size > 1      # More than 1 point
    assert np.any(raster)       # At least one '1'
    assert not np.all(raster)   # At least one '0'


    unit_step = direction / np.absolute(direction).max()

    # Determine what is the main axis: 0 is 'i', 1 is 'j'
    main_axis = unit_step[1] - unit_step[0] + (unit_step[1] == unit_step[0])   
    main_axis = main_axis/math.fabs(main_axis) 
    main_axis = int((main_axis + 1) / 2)

    path = np.array([0., 0.])

    while (is_sea(origin +path, cell_is_land)
           and small_distance(path, d_max)):
        path += unit_step

    # Backtrack 1 step if on land
    if cell_is_land(origin+path): path-=unit_step

    # Int rounding
    return (origin+path+0.5).astype(int)

def is_shore(point, land_raster):
    """ Determine if the current cell is on the shore, i.e. is water and
    adjascent to land """
   # This is my much less elegant solution.
    i = point[0] +0.5   # Rounding trick 
    j = point[1] +0.5   # Rounding

    # Point should be on sea, not on land
    if land_raster[i][j]: return False
    # If on sea, point shoud be bordered by land
    else:
        min_i = max(i-1, 0)
        max_i = min(i+2, land_raster.shape[0])
        min_j = max(j-1, 0)
        max_j = min(j+2, land_raster.shape[1])

        return land_raster[min_i:max_i, min_j:max_j].any()

def detect_shore_naive(land_raster):
    """ Naive shore detection algorithm which makes use of loops
        - Input:  numpy array of the land raster for which we want to find the shore
        - Output: same sized numpy array than input on which the shore is
            mapped as 1s, 0s averywhere else. 
        
        - Summary: Use is_shore on each point of the input"""
    shore=np.empty_like(land_raster)

    for j in range(land_raster.shape[0]):
        for i in range(land_raster.shape[1]):
            shore[i][j]=is_shore((i,j), land_raster)

    return shore

def detect_shore(land_raster):
    # Rich's super-short solution, which uses convolution.
    kernel = np.array([[-1,-1,-1],
                       [-1, 8,-1],
                       [-1,-1,-1]])

    return (sp.signal.convolve2d(land_raster,kernel,mode='same') <0).astype('int')
    
    
 
