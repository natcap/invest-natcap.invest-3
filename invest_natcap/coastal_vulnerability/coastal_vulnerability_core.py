import math
import numpy as np
import scipy as sp
from operator import mul


def execute(args):
    """ Entry point for coastal vulnerability core
    
        args['foo'] - actual data structure the way I want them look like


        returns nothing"""

    pass

def compute_vulnerability_index(r_geomorphology, r_relief, r_habitats, r_slr,
                                r_windexposure, r_waveexposure, r_surge):

    vi = count_var = 6

    return math.sqrt(r_geomorphology * r_relief * r_habitats * r_slr *
                     r_windexposure * r_waveexposure * r_surge)


def cast_ray(origin, direction, d_max, raster):
    """ Increment origin in discrete steps until eithre land is found, or
    d_max is met"""
    if not d_max: 
        return origin

    def set_raster(r):
        def raster_type_evaluator(position):
            return r[position[0], position[1]]
        return raster_type_evaluator

    cell_is_land = set_raster(raster)

    # Should check that raster has more than 1 point,
    # and that it contains at least 1 shore cell (one 0 and one 1)
    assert raster.size > 1      # More than 1 point
    assert np.any(raster)       # At least one '1'
    assert not np.all(raster)   # At least one '0'


    #print("origin:", origin, "is land:", cell_is_land(origin))

    unit_step = direction / np.absolute(direction).max()

    #print("unit step:", unit_step)

    # Determine what is the main axis: 0 is 'i', 1 is 'j'
    main_axis = unit_step[1] - unit_step[0] + (unit_step[1] == unit_step[0])   
    main_axis = main_axis/math.fabs(main_axis) 
    main_axis = int((main_axis + 1) / 2)

    path = np.array([0., 0.])
    #print(  "position:", origin + path,
    #        "is land:", cell_is_land(origin+path), 
    #        "long distance:", np.fabs(path[main_axis]) <d_max)

    while (not cell_is_land(origin +path)
           and (np.sqrt(np.sum(np.square(path))) <d_max)):
        path += unit_step
        #print("position:", (origin + path)[0], (origin+path)[1],
        #      "is land:", cell_is_land(origin+path), 
        #      "short distance:", np.sqrt(np.sum(np.square(path))) <d_max)


    # Backtrack 1 step if on land
    if cell_is_land(origin+path): path-=unit_step

    return origin +path

def is_shore(point, land_raster):
    """ Determine if the current cell is on the shore, i.e. is water and
    adjascent to land """
   # This is my much less elegant solution.
    i = point[0] +0.5   # Rounding trick 
    j = point[1] +0.5   # Rounding

    # Point should be on sea, not on land
    if land_raster[i][j]: return False
    # If on sea, point shoud be bordered by land
    else:
        min_i = max(i-1, 0)
        max_i = min(i+2, land_raster.shape[0])
        min_j = max(j-1, 0)
        max_j = min(j+2, land_raster.shape[1])

        return land_raster[min_i:max_i, min_j:max_j].any()

def detect_shore_naive(land_raster):
    """ Naive shore detection algorithm which makes use of loops
        - Input:  numpy array of the land raster for which we want to find the shore
        - Output: same sized numpy array than input on which the shore is
            mapped as 1s, 0s averywhere else. 
        
        - Summary: Use is_shore on each point of the input"""
    shore=np.empty_like(land_raster)

    for j in range(land_raster.shape[0]):
        for i in range(land_raster.shape[1]):
            shore[i][j]=is_shore((i,j), land_raster)

    return shore

def detect_shore(land_raster):
    # Rich's super-short solution, which uses convolution.
    kernel = np.array([[-1,-1,-1],
                       [-1, 8,-1],
                       [-1,-1,-1]])

    return (sp.signal.convolve2d(land_raster,kernel,mode='same') <0).astype('int')
    
    
 
