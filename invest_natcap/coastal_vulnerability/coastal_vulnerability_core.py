import math
import numpy as np
import scipy as sp
from operator import mul
from invest_natcap import raster_utils
from osgeo import gdal
from osgeo import ogr
import logging

LOGGER = logging.getLogger('coastal_vulnerability_core')
logging.basicConfig(format='%(asctime)s %(name)-15s %(levelname)-8s \
    %(message)s', level=logging.DEBUG, datefmt='%m/%d/%Y %H:%M:%S ')

def sea():
    """ Return the code for a sea cell """
    return 0;

def land():
    """ Return the code for a land cell """
    return 1;

def nodata():
    """ Return the code for a nodata cell """
    return -1

def shore():
    """ Return the code for a shore cell """
    return 1

def is_sea(position, raster):
    """ Return True if the cell is sea (code 0), False otherwise 

        Inputs: - current cell position
                - raster where the cell value is stored 
                
        Output: - True if sea, False otrherwise"""
    return (raster[position[0], position[1]] == sea())

def is_land(position, raster):
    """ Return True if the cell is on land (code 1), False otherwise 

        Inputs: - current cell position
                 - raster where the cell value is stored
                
        Output: - True if sea, False otrherwise"""
    return (raster[position[0], position[1]] == land())

def execute(args):
    """ Entry point for coastal vulnerability core
    
        args['foo'] - actual data structure the way I want them look like


        returns nothing"""

    pass

def compute_vulnerability_index(r_geomorphology, r_relief, r_habitats, r_slr,
                                r_windexposure, r_waveexposure, r_surge):

    vi = count_var = 6

    return math.sqrt(r_geomorphology * r_relief * r_habitats * r_slr *
                     r_windexposure * r_waveexposure * r_surge)


def convert_shape_to_raster(shapefile, aoi, cell_size):
    # Try to open the area of interest:
    try:
        with open(aoi) as f: pass        
    except IOError as e:
        print("File ", aoi, " doesn't exist...")

    # Try to open the shapefile:
    try:
        with open(shapefile) as g: pass        
    except IOError as e:
        print("File ", shapefile, " doesn't exist...")

    aoi_datasource = ogr.Open(aoi)
    global_datasource = ogr.Open(shapefile)

    aoi_layer = aoi_datasource.GetLayer(0)
    global_layer = global_datasource.GetLayer(0)

    aoi_raster_filename = 'aoi_raster.tif'
    global_raster_filename = 'global_raster.tif'
    #Creation of the raster itself, into the URI we just named
    aoi_raster = \
        raster_utils.create_raster_from_vector_extents(cell_size, cell_size,
        gdal.GDT_Int32, nodata(), aoi_raster_filename, aoi_datasource)

    global_dataset = raster_utils.new_raster_from_base(aoi_raster, 
        global_raster_filename, 'GTiff', nodata(), gdal.GDT_Int32)

    global_raster = \
        raster_utils.create_raster_from_vector_extents(cell_size, cell_size,
        gdal.GDT_Int32, nodata(), global_raster_filename, global_datasource)

    aoi_band, aoi_nodata = \
        raster_utils.extract_band_and_nodata(aoi_raster)

    global_band, global_nodata = \
        raster_utils.extract_band_and_nodata(global_dataset)

    aoi_band.Fill(aoi_nodata)
    gdal.RasterizeLayer(aoi_raster, [1], aoi_layer, burn_values=[1])

    global_band.Fill(global_nodata)
    gdal.RasterizeLayer(global_dataset, [1], global_layer, burn_values=[land()])

    aoi_array = aoi_band.ReadAsArray()
    global_array = global_band.ReadAsArray()

    land_sea_array = np.ones_like(global_array)

    land_sea_array[global_array == global_nodata] = 0
    land_sea_array[aoi_array == aoi_nodata] = nodata()

#    land_sea_filename = 'land_sea_raster.tif'

#    drv = gdal.GetDriverByName("GTiff")
#    ds = drv.Create(land_sea_filename, 
#                    land_sea_array.shape[1],
#                    land_sea_array.shape[0], 
#                    1, gdal.GDT_Float32)

#    land_sea_band = ds.GetRasterBand(1)
#    land_sea_band.SetNoDataValue(nodata())
#    land_sea_band.WriteArray(land_sea_array)

#    ds = None
#    drv = None

    aoi_datasource = None
    global_datasource = None
    
    return land_sea_array

def small_distance(path, d_max):
    """ Return if distance is within a threshold minus an epsilon """
    return (np.sqrt(np.sum(np.square(path))) <(d_max-0.0001))

def cast_ray(origin, direction, d_max, raster):
    """ March from the origin towards a direction until either land or a
    maximum distance is met. Origin s to be on sea.
    
        Inputs: - origin: algorithm's starting point
                - direction: marching direction
                - d_max: maximum distance to traverse
                - raster: land mass raster
        
        Output: - distance to the origin """
    # Requirement: we want the origin to be integer values
    assert(math.ceil(origin[0]) == origin[0])
    assert(math.ceil(origin[1]) == origin[1])

    # Not on sea, no fetch
    if not is_sea(origin, raster): return origin

    # No distance, no fetch
    if (d_max < 0.5): 
        print("d_max = ", d_max, "no distance, no fetch")
        return origin

    # Should check that raster has more than 1 point,
    # and that it contains at least 1 shore cell (one 0 and one 1)
    assert raster.size > 1      # More than 1 point

    unit_step = direction / np.absolute(direction).max()

    # Determine what is the main axis: 0 is 'i', 1 is 'j'
    main_axis = unit_step[1] - unit_step[0] + (unit_step[1] == unit_step[0])   
    main_axis = main_axis/math.fabs(main_axis) 
    main_axis = int((main_axis + 1) / 2)

    path = np.array([0., 0.])

    while (is_sea(origin +path, raster)
           and small_distance(path, d_max)):
        path += unit_step

    # Backtrack 1 step if on land
    if is_land(origin+path, raster): path-=unit_step

    return np.sqrt(np.sum(np.square(path)))

def detect_shore(raster):
    """ Return the boundary with land from a raster.
    The boundary could be anything between land and any other land code."""
    # Rich's super-short solution, which uses convolution.
    # Works if land is 1, sea is 0, and nodata is -1:
    assert(land()   ==  1)
    assert(sea()    ==  0)
    assert(nodata() == -1)

    kernel = np.array([[-1,-1,-1],
                       [-1, 8,-1],
                       [-1,-1,-1]])

    return (sp.signal.convolve2d(raster,kernel,mode='same') <0).astype('int')
    
def compute_fetch(land_raster, directions, d_max):
    """ Given a land raster, return the fetch distance from a point
    in given directions 
    
        Inputs: - land_raster: raster where land is encoded as 1s, sea as 0s,
                  and cells outside the area of interest as anything 
                  different from 0s or 1s.
                - directions: tuple of angles (in radians) from which the fetch
                  will be computed for each pixel.
                - d_max: maximum distance over which to compute the fetch
                
        
        Output: - dictionary of fetch data where the key is a coordinate tuple,
                  and the value is a tuple of the size of directions containing 
                  fetch distances for that point.
        
        Summary: """
    # Extract shore from raster
    shore_raster = detect_shore(land_raster)

    shore_points = shore_raster[shore_raster == shore()]
    
    #print(shore_points)


    pass



