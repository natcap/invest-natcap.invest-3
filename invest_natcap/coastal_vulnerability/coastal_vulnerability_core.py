import math
import numpy as np
import scipy as sp
from operator import mul
from invest_natcap import raster_utils
from osgeo import gdal
from osgeo import ogr
import logging

LOGGER = logging.getLogger('coastal_vulnerability_core')
logging.basicConfig(format='%(asctime)s %(name)-15s %(levelname)-8s \
    %(message)s', level=logging.DEBUG, datefmt='%m/%d/%Y %H:%M:%S ')

def sea():
    """ Return the code for a sea cell """
    return 0;

def land():
    """ Return the code for a land cell """
    return 1;

def is_sea(position, raster):
    """ Return True if the cell is sea (code 0), False otherwise 

        Inputs: - current cell position
                - raster where the cell value is stored 
                
        Output: - True if sea, False otrherwise"""
    return (raster[position[0], position[1]] == sea())

def is_land(position, raster):
    """ Return True if the cell is on land (code 1), False otherwise 

        Inputs: - current cell position
                 - raster where the cell value is stored
                
        Output: - True if sea, False otrherwise"""
    return (raster[position[0], position[1]] == land())

def execute(args):
    """ Entry point for coastal vulnerability core
    
        args['foo'] - actual data structure the way I want them look like


        returns nothing"""

    pass

def compute_vulnerability_index(r_geomorphology, r_relief, r_habitats, r_slr,
                                r_windexposure, r_waveexposure, r_surge):

    vi = count_var = 6

    return math.sqrt(r_geomorphology * r_relief * r_habitats * r_slr *
                     r_windexposure * r_waveexposure * r_surge)


def convert_shape_to_raster(args):
    #Essentially turns a shapefile into a grid!
    aoi_features    = args['working_directory'] + args['aoi']
    global_features = args['working_directory'] + args['global_polygon']

    # Try to open the area of interest:
    try:
        with open(aoi_features) as f: pass        
    except IOError as e:
        print("File ", aoi_features, " doesn't exist...")

    # Try to open the area of interest:
    try:
        with open(global_features) as g: pass        
    except IOError as e:
        print("File ", global_features, " doesn't exist...")

    aoi_datasource = ogr.Open(aoi_features)
    global_datasource = ogr.Open(global_features)

    aoi_layer = aoi_datasource.GetLayer(0)
    global_layer = global_datasource.GetLayer(0)

    cell_size =args['cell_size'] 
    aoi_raster_filename = 'aoi_raster.tif'
    global_raster_filename = 'global_raster.tif'
    #Creation of the raster itself, into the URI we just named
    aoi_raster = \
        raster_utils.create_raster_from_vector_extents(cell_size, cell_size,
        gdal.GDT_Int32, -1, aoi_raster_filename, aoi_datasource)

    global_dataset = raster_utils.new_raster_from_base(aoi_raster, 
        global_raster_filename, 'GTiff', -1, gdal.GDT_Int32)

    global_raster = \
        raster_utils.create_raster_from_vector_extents(cell_size, cell_size,
        gdal.GDT_Int32, -1, global_raster_filename, global_datasource)

    aoi_band, aoi_nodata = \
        raster_utils.extract_band_and_nodata(aoi_raster)

    global_band, global_nodata = \
        raster_utils.extract_band_and_nodata(global_dataset)

    aoi_band.Fill(aoi_nodata)
    gdal.RasterizeLayer(aoi_raster, [1], aoi_layer, burn_values=[1])

    global_band.Fill(global_nodata)
    gdal.RasterizeLayer(global_dataset, [1], global_layer, burn_values=[land()])

    aoi_array = aoi_band.ReadAsArray()
    global_array = global_band.ReadAsArray()

    land_sea_nodata = -1.0
    land_sea_array = np.ones_like(global_array)

    land_sea_array[global_array == global_nodata] = 0
    land_sea_array[aoi_array == aoi_nodata] = land_sea_nodata

    land_sea_filename = 'land_sea_raster.tif'

    drv = gdal.GetDriverByName("GTiff")
    ds = drv.Create(land_sea_filename, 
                    land_sea_array.shape[1],
                    land_sea_array.shape[0], 
                    1, gdal.GDT_Float32)

    land_sea_band = ds.GetRasterBand(1)
    land_sea_band.SetNoDataValue(land_sea_nodata)
    land_sea_band.WriteArray(land_sea_array)

    aoi_datasource = None
    global_datasource = None
    
    ds = None
    drv = None

    # Should save the raster and use it for a regression test
    return land_sea_array

def small_distance(path, d_max):
    """ Return if distance is within a threshold minus an epsilon """
    return (np.sqrt(np.sum(np.square(path))) <(d_max-0.0001))

def cast_ray(origin, direction, d_max, raster):
    """ March from the origin towards a direction until either land or a
    maximum distance is met. Origin s to be on sea.
    
        Inputs: - algorithm's starting point
                - marching direction
                - maximum distance to traverse
                - land mass raster
        
        Output: - position of the algorithm's last point """
    # We want the origin to be integer values (Is it fine to assert this?)
    assert(math.ceil(origin[0]) == origin[0])
    assert(math.ceil(origin[1]) == origin[1])

    # Not on sea, no fetch
    if not is_sea(origin, raster): return origin

    # No distance, no fetch
    if (d_max < 0.5): return origin

    # Should check that raster has more than 1 point,
    # and that it contains at least 1 shore cell (one 0 and one 1)
    assert raster.size > 1      # More than 1 point

    unit_step = direction / np.absolute(direction).max()

    # Determine what is the main axis: 0 is 'i', 1 is 'j'
    main_axis = unit_step[1] - unit_step[0] + (unit_step[1] == unit_step[0])   
    main_axis = main_axis/math.fabs(main_axis) 
    main_axis = int((main_axis + 1) / 2)

    path = np.array([0., 0.])

    while (is_sea(origin +path, raster)
           and small_distance(path, d_max)):
        path += unit_step

    # Backtrack 1 step if on land
    if is_land(origin+path, raster): path-=unit_step

    return np.sqrt(np.sum(np.square(path)))

def detect_shore(raster):
    """ Return the boundary with land from a raster.
    The boundary could be anything between land and any other land code."""
    # Rich's super-short solution, which uses convolution.
    kernel = np.array([[-1,-1,-1],
                       [-1, 8,-1],
                       [-1,-1,-1]])

    return (sp.signal.convolve2d(raster,kernel,mode='same') <0).astype('int')
    
def fetch_distance(i, j, d_max, land_raster, direction):
    """ Given a land raster, return the fetch distance from a point
    in a given direction """


