""" Coastal vulnerability model core functions """
import math
import numpy as np
import scipy as sp

from osgeo import gdal
from osgeo import ogr
from osgeo import osr

import logging
from invest_natcap import raster_utils

class NotAtSea(Exception): 
    """ Exception raised by cast_ray when the point for which to compute the
    fetch is not at sea """
    pass


LOGGER = logging.getLogger('coastal_vulnerability_core')
logging.basicConfig(format='%(asctime)s %(name)-15s %(levelname)-8s \
    %(message)s', level=logging.DEBUG, datefmt='%m/%d/%Y %H:%M:%S ')

def execute(args):
    """ Entry point for coastal vulnerability core
    
        For lots of debug output and data storage code, 
        check out revision 4318:705d54ae6c37

        args['foo'] - actual data structure the way I want them look like


        returns nothing"""

    pass

def sea():
    """ Return the code for a sea cell """
    return 0

def land():
    """ Return the code for a land cell """
    return 1

def nodata():
    """ Return the code for a nodata cell """
    return -1

def shore():
    """ Return the code for a shore cell """
    return 1

def is_sea(position, raster):
    """ Determine whether the cell is at sea or not.

        - position: current cell position
        - raster: array used to determine the cell value
                
        Returns True if the cell is at sea, False otrherwise."""
    return (raster[position[0], position[1]] == sea())

def is_land(position, raster):
    """ Determine whether the cell is on land or not. 

        - position: current cell position
        - raster: raster where the cell value is stored
                
        Returns True if the cell is at sea, False otrherwise."""
    return (raster[position[0], position[1]] == land())

def compute_vulnerability_index(r_geomorphology, r_relief, r_habitats, r_slr,
                                r_windexposure, r_waveexposure, r_surge):
    """ Main function that computes a coastal vulnerability index.
    
        r_geomorphology:
        r_relief:
        r_habitats:
        r_slr:
        r_windexposure:
        r_waveexposure:
        r_surge:
        
        returns something that is to be determined."""
    #vi = count_var = 6

    return math.sqrt(r_geomorphology * r_relief * r_habitats * r_slr *
                     r_windexposure * r_waveexposure * r_surge)

def compute_wind_exposure(wind_data_file, aoi):
    """ Compute the wind exposure for every shore segment"""
    try:
        with open(wind_data_file):
            pass
            #LOGGER.debug("Found %s" % str(wind_data_file))
    except IOError:
        LOGGER.debug("File %s doesn't exist." % str(wind_data_file))
    
    aoi_datasource = ogr.Open(aoi)
    aoi_layer = aoi_datasource.GetLayer(0)

    WW3_datasource = ogr.Open(wind_data_file)
    WW3_layer = WW3_datasource.GetLayer(0)
    WW3_cloned_layer = WW3_datasource.CopyLayer(WW3_layer, "cloned WW3 layer")
    
    # Converting WaveWatch3 spatial reference (SR) to the AOI's
    source_SR = WW3_layer.GetSpatialRef()
    #source_SR = osr.SpatialReference()
    #source_SR.ImportFromProj4(WW3_layer.GetSpatialRef().ExportToProj4())

    destination_SR = aoi_layer.GetSpatialRef()
    #destination_SR = osr.SpatialReference()
    #destination_SR.ImportFromProj4(aoi_layer.GetSpatialRef().ExportToProj4())

    sr_transform = osr.CoordinateTransformation(source_SR, destination_SR)


    aoi_feature = aoi_layer.GetFeature(0)
    aoi_geom = aoi_feature.GetGeometryRef()

    features_in_aoi = 0

    for feature in WW3_layer:
        feature_definition = WW3_layer.GetLayerDefn()
        WW3_geom = feature.GetGeometryRef()
        WW3_geom.Transform(sr_transform)

        if aoi_geom.Contains(WW3_geom):
            features_in_aoi += 1

        print(feature.items()['LAT'], feature.items()['LONG'])
        
    print("features in AOI:", features_in_aoi)
 
    
    """Changes the projection of a shapefile by creating a new shapefile 
    based on the projection passed in.  The new shapefile then copies all the 
    features and fields of the shapefile to reproject as its own. 
    The reprojected shapefile is written to 'outputpath' and is returned.
     
    shape_to_reproject - A shapefile to be copied and reprojected.
    target_sr - The desired projection as a SpatialReference from a WKT string.
    output_path - The path to where the new shapefile should be written to 
    disk.
     
    returns - The reprojected shapefile.
    """
    #Get the layer of points from the current point geometry shape
    #in_layer = shape_to_reproject.GetLayer(0)
    #Get the layer definition which holds needed attribute values
    #in_defn = in_layer.GetLayerDefn()
    #Create a new shapefile with similar properties of the current 
    #point geometry shape
    #shp_driver = ogr.GetDriverByName('ESRI Shapefile')
    #shp_ds = shp_driver.CreateDataSource(shape_source)
    #Create the new layer for the shapefile using same name and geometry
    #type from shape_to_reproject, but different projection
    #shp_layer = shp_ds.CreateLayer(in_defn.GetName(), target_sr, \
    #                                in_defn.GetGeomType())
    #Get the number of fields in the current point shapefile
    #in_field_count = in_defn.GetFieldCount()
    #For every field, create a duplicate field and add it to the new 
    #shapefiles layer
    #for fld_index in range(in_field_count):
    #    src_fd = in_defn.GetFieldDefn(fld_index)
    #    fd_def = ogr.FieldDefn(src_fd.GetName(), src_fd.GetType())
    #    fd_def.SetWidth(src_fd.GetWidth())
    #    fd_def.SetPrecision(src_fd.GetPrecision())
    #    shp_layer.CreateField(fd_def)
 
    # in_layer.ResetReading()
    #Get the spatial reference of the source layer to use in transforming
    # source_sr = in_layer.GetSpatialRef()
    #Create a coordinate transformation
    # coord_trans = osr.CoordinateTransformation(source_sr, target_sr)
    #Get the first feature from the shapefile
    # in_feat = in_layer.GetNextFeature()
    #Copy all of the features in shape_to_reproject to the new shapefile
    #while in_feat is not None:
    #     geom = in_feat.GetGeometryRef()
         #Transform the geometry into a format desired for the new projection
    #     geom.Transform(coord_trans)
         #Copy shape_to_reproject's feature and set as new shapes feature
    #     out_feat = ogr.Feature(feature_def=shp_layer.GetLayerDefn())
    #     out_feat.SetFrom(in_feat)
    #     out_feat.SetGeometry(geom)
         #For all the fields in the feature set the field values from the 
         #source field
    #     for fld_index2 in range(out_feat.GetFieldCount()):
    #         src_field = in_feat.GetField(fld_index2)
    #         out_feat.SetField(fld_index2, src_field)
 
    #     shp_layer.CreateFeature(out_feat)
    #     out_feat.Destroy()
 
    #     in_feat.Destroy()
    #     in_feat = in_layer.GetNextFeature()
 
    #return shp_ds


    # So... burn the shapes on a raster within the AOI:
    #aoi_raster_filename = 'aoi_WW3_raster.tif'
    #WW3_raster_filename = 'WW3_raster.tif'

    #aoi_raster = \
    #    raster_utils.create_raster_from_vector_extents(250, 250,
    #    gdal.GDT_Int32, nodata(), aoi_raster_filename, aoi_datasource)

    #WW3_dataset = raster_utils.new_raster_from_base(aoi_raster, 
    #    WW3_raster_filename, 'GTiff', nodata(), gdal.GDT_Int32)

    
    # Get the band and nodata for each file
    #aoi_band, aoi_nodata = \
    #    raster_utils.extract_band_and_nodata(aoi_raster)

    #WW3_band, WW3_nodata = \
    #    raster_utils.extract_band_and_nodata(WW3_dataset)

    # Initialize the band and burn the shapefile on it for each file
    #aoi_band.Fill(aoi_nodata)
    #gdal.RasterizeLayer(aoi_raster, [1], aoi_layer, burn_values=[land()])

    #WW3_band.Fill(WW3_nodata)
    # Reprojection failed here...
    #gdal.RasterizeLayer(WW3_dataset, [1], aoi_layer, burn_values=[land()])

    # Extract the array from the bands
    #aoi_array = aoi_band.ReadAsArray()
    #WW3_array = WW3_band.ReadAsArray()


    #ds = gdal.Open("./aoi_raster.tif")
    #band = ds.GetRasterBand(1)
    #aoi_raster = band.ReadArray()

    #WW3_filename = 'WW3_raster'

    #WW3_raster =\
    #    raster_utils.new_raster_from_base(aoi_raster, WW3_filename, 'GTiff',
    #    nodata(), 250, 250, gdal.GDT_Int32)

    #land_sea_filename = 'land_sea_raster.tif' 

    #drv = gdal.GetDriverByName("GTiff")
    #ds = drv.Create(land_sea_filename,
    #                land_sea_array.shape[1],
    #                land_sea_array.shape[0],
    #                1,
    #                gdal.GDT_Float32)

    #land_sea_band = ds.GetRasterBand(1)
    #land_sea_band.SetNoDataValue(nodata())
    #land_sea_band.WriteArray(land_sea_array)

    #ds = None
    #drv = None


    # Clean up
    WW3_layer = None
    WW3_datasource = None

    pass

def convert_shape_to_raster(shapefile, aoi, cell_size):
    """ Convert a shapefile to a raster file.
    
        - shapefile: location of the shapefile to be rasterized
        - aoi: location of the shapefile containing the area of interest
        - cell_size: granularity of the rasterization
        
        Returns a raster file with cell codes for land, sea, and nodata."""
    # Try to open the area of interest:
    try:
        with open(aoi): 
            pass        
    except IOError:
        print("File ", aoi, " doesn't exist...")

    # Try to open the shapefile:
    try:
        with open(shapefile): 
            pass        
    except IOError:
        print("File ", shapefile, " doesn't exist...")

    # Open the shapefiles, and extract the shapes from the first layers
    aoi_datasource = ogr.Open(aoi)
    global_datasource = ogr.Open(shapefile)

    aoi_layer = aoi_datasource.GetLayer(0)
    global_layer = global_datasource.GetLayer(0)

    aoi_raster_filename = 'aoi_raster.tif'
    global_raster_filename = 'global_raster.tif'

    aoi_raster = \
        raster_utils.create_raster_from_vector_extents(cell_size, cell_size,
        gdal.GDT_Int32, nodata(), aoi_raster_filename, aoi_datasource)

    global_dataset = raster_utils.new_raster_from_base(aoi_raster, 
        global_raster_filename, 'GTiff', nodata(), gdal.GDT_Int32)

    
    # Get the band and nodata for each file
    aoi_band, aoi_nodata = \
        raster_utils.extract_band_and_nodata(aoi_raster)

    global_band, global_nodata = \
        raster_utils.extract_band_and_nodata(global_dataset)

    # Initialize the band and burn the shapefile on it for each file
    aoi_band.Fill(aoi_nodata)
    gdal.RasterizeLayer(aoi_raster, [1], aoi_layer, burn_values=[land()])

    global_band.Fill(global_nodata)
    gdal.RasterizeLayer(global_dataset, [1], global_layer, burn_values=[land()])

    # Extract the array from the bands
    aoi_array = aoi_band.ReadAsArray()
    global_array = global_band.ReadAsArray()

    # Initialize the raster with land, sea, and nodata cells
    landmass_array = np.ones_like(global_array) * land()
    landmass_array[global_array == global_nodata] = sea()
    landmass_array[aoi_array == aoi_nodata] = nodata()

    # cleanup before returning
    aoi_datasource = None
    global_datasource = None
    
    return landmass_array

def small_distance(path, d_max):
    """ Determines if the path length is within a threshold minus an epsilon.
    
        - path: coordinates used to compute the distance.
        - d_max: distance threshold.
        
        Returns true if pathlength is clearly (up to an epsilon) 
        below the distance threshold."""
    return (np.sqrt(np.sum(np.square(path))) <(d_max-0.0001))

def cast_ray(origin, direction, d_max, raster):
    """ March from the origin towards a direction until either land or a
    maximum distance is met.
    
        - origin: algorithm's starting point -- has to be on sea
        - direction: marching direction
        - d_max: maximum distance to traverse
        - raster: land mass raster
        
        Returns the distance to the origin."""
    # Rounding the origin, and name it 'O', as the origin is named 
    # in the cartesian coordinate system
    O = np.around(np.array(list(origin)))

    # Not on sea, no fetch
    if not is_sea(O, raster): 
        raise NotAtSea('Not at sea, no fetch')

    # Short distance, no fetch
    if (d_max < 1.0): 
        return 0.0

    # Preliminary checks
    assert raster.size > 1      # More than 1 point
    assert(np.fabs(direction).max() > 0) # Non-zero vector

    unit_step = direction / np.fabs(direction).max()

    # Determine what is the main axis: 0 is 'i', 1 is 'j'
    main_axis = unit_step[1] - unit_step[0] + (unit_step[1] == unit_step[0])   
    main_axis = main_axis/math.fabs(main_axis) 
    main_axis = int((main_axis + 1) / 2)

    path = np.array([0., 0.])

    while (is_sea(np.around(O +path), raster)
           and small_distance(path, d_max)):
        path += unit_step

    # Backtrack 1 step if on land
    if is_land(np.around(O +path), raster): 
        path -= unit_step

    return np.sqrt(np.sum(np.square(path)))

def detect_shore(raster):
    """ Extract the boundary between land and sea from a raster.
    
        - raster: numpy array with sea, land and nodata values.
        
        returns a numpy array the same size as the input raster with the shore
        encoded as ones, and zeros everywhere else."""
    # Rich's super-short solution, which uses convolution.
    # Works if land, sea, and nodata have different values:
    assert(land()   != sea())
    assert(sea()    != nodata())
    assert(nodata() != land())

    kernel = np.array([[-1, -1, -1],
                       [-1,  8, -1],
                       [-1, -1, -1]])

    # Generate the nodata shore artifacts
    aoi = np.ones_like(raster) * sea()
    aoi[raster == nodata()] = nodata()

    negative_borders = (sp.signal.convolve2d(aoi, \
                                            kernel, \
                                            mode='same') <0 ).astype('int')

    # Generate the real borders (including data artifacts)
    borders = (sp.signal.convolve2d(raster, \
                                 kernel, \
                                 mode='same') <0 ).astype('int')
    
    # Useful borders = all borders - borders from nodata
    borders = ((borders - negative_borders) >0 ).astype('int') * shore()

    return borders
    
def compute_fetch(land_raster, directions, d_max):
    """ Given a land raster, return the fetch distance from a point
    in given directions 
        
        - land_raster: raster where land is encoded as 1s, sea as 0s,
            and cells outside the area of interest as anything 
            different from 0s or 1s.
        - directions: tuple of angles (in radians) from which the fetch
            will be computed for each pixel.
        - d_max: maximum distance over which to compute the fetch
                
        
        returns:dictionary of fetch data where the key is a shore point
                coordinates, and the value is a tuple (same size as directions) 
                containing fetch distances from that point."""
    # Extract shore from raster
    shore_raster = detect_shore(land_raster)
    shore_points = np.where(shore_raster == shore())
    
    # precompute directions
    direction_vectors = np.empty((len(directions), 2))

    for d in range(len(directions)):
        direction_vectors[d] = (math.cos(directions[d]), math.sin(directions[d]))

    fetch = {}

    # Compute fetch for each point (i, j)
    for point in zip(shore_points[0], shore_points[1]):
        try:
            fetch[point] = ()
            for direction in direction_vectors:
                d = cast_ray(point, direction, d_max, land_raster)
                fetch[point] = fetch[point] + (d,)
        except NotAtSea:
            del(fetch[point])

    return fetch

