from __future__ import print_function

import unittest
import logging
import os
import subprocess

from osgeo import gdal
from nose.plugins.skip import SkipTest
import math
import numpy as np
import random

from invest_natcap.coastal_vulnerability import coastal_vulnerability
import invest_cython_core
import invest_test_core


LOGGER = logging.getLogger('coastal_vulnerability_test')
logging.basicConfig(format='%(asctime)s %(name)-15s %(levelname)-8s \
    %(message)s', level=logging.DEBUG, datefmt='%m/%d/%Y %H:%M:%S ')

class TestCoastalVulnerability(unittest.TestCase):
    """Main testing class for the coastal vulnerability tests"""
    
    def setUp(self):
        """ Set up a test coastline on which to use the marching square
        algorithm 
        
            - inputs: none (hard-coded coastline, hard-coded ray directions)
            - output: an array of (type?) 2-tuples (direction, length)
        """

        sides =10       # Size of the array in cells (sides * sides)
        border =2       # Number of zero cells around the perimeter (artificial shore)
        directions =4   # Number of directions in which the rays are going to be cast

        coastline = np.ones((sides, sides), dtype=np.int)
        coastline[border:(sides-border), border:(sides-border)] = 0

        self.coastline = coastline
        self.sides = sides

        
    def test_cast_rays(self):
        """ Test the ray-casting algorithm on an artificial test coastline
            - inputs: none
            - outputs: a ray_cast_test.tif file
            
            Description: 
                1- Takes a predefined coastline and detect the shoreline
                2- Run the marching square algorithm on each shoreline point
            """

        print("\n", self.coastline)

        # 1- Detect the shoreline.
        #   1.1- Find the first point on the shore by picking a point at random
        #       Will draw two points until one is on the ground, and one is on
        #       sea. Then we'll use the marching square algorithm to find the
        #       shore.
        def pick_point (): return np.array([float(random.randint(0,self.sides-1)),
                                            float(random.randint(0,self.sides-1))])

        def set_raster(raster):
            def raster_type_evaluator(position):
                return raster[position[0], position[1]]
            return raster_type_evaluator

        first_point  = pick_point()
        second_point = pick_point()

        coastline_raster = set_raster(self.coastline)


        while coastline_raster(first_point) == coastline_raster(second_point):
            second_point = pick_point()

        v = second_point - first_point
        v_length = np.sqrt(np.sum(v*v))
        v_norm = v / v_length

        # Determine what is the main axis index: 0 is 'i', 1 is 'j'
        major_axis_index = np.fabs(v[1]) - np.fabs(v[0]) # Positive or negative   
        # Normalized to -1 or +1
        major_axis_index = major_axis_index/math.fabs(major_axis_index) 
        # Normalized to 0 or 1
        major_axis_index = (major_axis_index + 1.) / 2.

        major_axis = np.zeros((2,), dtype=np.float)
        major_axis[major_axis_index] = 1
        minor_axis = np.ones((2,), dtype=np.float) - major_axis


        print("\n", self.coastline)
        print("1st point:", first_point, "type=", coastline_raster(first_point))
        print("2nd point:", second_point,"type=", coastline_raster(second_point))
        print("v:", v)
        print("normalized vector: ", v_norm, "length=", v_length)
        print("index:", major_axis_index)
        print("major_axis:", major_axis)
        print("minor_axis:", minor_axis)

    def test_coastal_vulnerability(self):
        base_dir = 'data/test_out/coastal_vulnerability_core'

        if not os.path.exists(base_dir):
            os.makedirs(base_dir)

        vi_uri = os.path.join(base_dir,'vi.tif')

        args = {}

        args['vi_uri'] = vi_uri

        coastal_vulnerability.execute(args)

        #check correctness of output

    def tare_down(self):
        # Clean-up code here
        # Do nothing for now 
        pass
