from __future__ import print_function

import unittest
import logging
import os
import subprocess

from osgeo import gdal
from nose.plugins.skip import SkipTest
import math
import numpy as np
import random
import time

from invest_natcap.coastal_vulnerability import coastal_vulnerability
from invest_natcap.coastal_vulnerability import coastal_vulnerability_core
import invest_cython_core
import invest_test_core


LOGGER = logging.getLogger('coastal_vulnerability_test')
logging.basicConfig(format='%(asctime)s %(name)-15s %(levelname)-8s \
    %(message)s', level=logging.DEBUG, datefmt='%m/%d/%Y %H:%M:%S ')

class TestCoastalVulnerability(unittest.TestCase):
    """Main testing class for the coastal vulnerability tests"""
    
    def setUp(self):
        """ Set up a test coastline on which to use the marching square
        algorithm 
        
            - inputs: none (hard-coded coastline, hard-coded ray directions)
            - output: an array of (type?) 2-tuples (direction, length)
        """

        sides =100       # Size of the array in cells (sides * sides)
        border =2       # Number of zero cells around the perimeter (artificial shore)

        coastline = np.ones((sides, sides), dtype=np.int)
        coastline[border:(sides-border), border:(sides-border)] = 0

        self.coastline = coastline
        self.sides = sides

    def test_convert_shape_to_raster(self):
        coastal_vulnerability_core.convert_shape_to_raster()
        pass

    def test_detect_shore(self):
        shore_naive=coastal_vulnerability_core.detect_shore_naive(self.coastline)
        shore=coastal_vulnerability_core.detect_shore(self.coastline)

        #print("shore from naive algorithm:\n", shore_naive)
        #print("shore from other algorithm:\n", shore)
        
        #print("Difference:", np.sum(shore-shore_naive))
        
        self.assertEquals(np.sum(shore - shore_naive), 0)

    def test_cast_rays(self):
        """ Test the ray-casting algorithm on an artificial test coastline
            - inputs: none
            - outputs: a ray_cast_test.tif file
            
            Description: 
                1- Takes a predefined coastline and detect the shoreline
                2- Run the marching square algorithm on each shoreline point
            """

        origin = np.array([self.coastline.shape[0]/2, self.coastline.shape[1]/2])
        radius = min(self.coastline.shape)/4
        d_max = radius
        raster = self.coastline

        test_data = np.empty((100, 2))
        result_data = np.empty_like(test_data)

        test_data = np.array([np.array([random.randint(1, radius+1)+origin[0], 
                                        random.randint(1, radius+1)+origin[1]])
                                for x in range(test_data.shape[0])])

        should_stop_on_land = np.array([random.choice((True, False))
                                for i in range(test_data.shape[0])])
        direction = (test_data - origin).astype(float)
        old_raster_val = 0

        for i in range(test_data.shape[0]):
            d_max = np.sqrt(np.sum(np.square(direction[i])))
            direction[i] /= d_max #max(np.fabs(direction)) 

            if should_stop_on_land[i]:
                d_max *=2
                land = (direction[i] / max(np.fabs(direction[i]))) + test_data[i]
                old_raster_val = raster[land[0]][land[1]]
                raster[land[0]][land[1]] = 1
            #print("\norigin=", origin)
            #print("destination=", test_data[i])
            #print("direction=", direction)
            #print("d_max=", d_max)
            result_data[i] = coastal_vulnerability_core.cast_ray(
                                origin, direction[i], d_max, raster)

            if should_stop_on_land[i]: raster[land[0]][land[1]]=old_raster_val
            #raster[origin[0]][origin[1]] = 2
            #raster[test_data[i][0]][test_data[i][1]] = 3
            #raster[result_data[i][0]][result_data[i][1]] =4 
            #print(raster)
 
 
        report_data = np.empty((test_data.shape[0],9), dtype=int)

        report_data[:,0:2] = test_data
        report_data[:,2:4] = direction
        report_data[:,4:6] = result_data
        report_data[:,6]   = should_stop_on_land
        report_data[:,7:9] = test_data - result_data

        #print("\nreport data:", report_data)
        
        error = np.sum(np.fabs(report_data[:, 7:9]))
        
        print("\nError:", error)

        if error:
            print("Entries at fault:\n",
                report_data[np.where(( np.fabs(report_data[:,7]) +
                                       np.fabs(report_data[:,8]))>0)])

        self.assertEquals(error, 0)

    def test_coastal_vulnerability(self):
        base_dir = 'data/test_out/coastal_vulnerability_core'

        if not os.path.exists(base_dir):
            os.makedirs(base_dir)

        vi_uri = os.path.join(base_dir,'vi.tif')

        args = {}

        args['vi_uri'] = vi_uri

        coastal_vulnerability.execute(args)

        #check correctness of output

    def tare_down(self):
        # Clean-up code here
        # Do nothing for now 
        pass
