from __future__ import print_function

import unittest
import logging
import os
import subprocess

from osgeo import gdal
from nose.plugins.skip import SkipTest
import math
import numpy as np
import random
import time
import csv

from invest_natcap.coastal_vulnerability \
    import coastal_vulnerability as cv
from invest_natcap.coastal_vulnerability \
    import coastal_vulnerability_core as cvc
import invest_cython_core
import invest_test_core


LOGGER = logging.getLogger('coastal_vulnerability_test')
logging.basicConfig(format='%(asctime)s %(name)-15s %(levelname)-8s \
    %(message)s', level=logging.DEBUG, datefmt='%m/%d/%Y %H:%M:%S ')

class TestCoastalVulnerability(unittest.TestCase):
    """Main testing class for the coastal vulnerability tests"""
    
    def setUp(self):
        """ Set up a test coastline on which to use the marching square
        algorithm 
        
            - inputs: none (hard-coded coastline, hard-coded ray directions)
            - output: an array of (type?) 2-tuples (direction, length)
        """

        sides =100       # Size of the array in cells (sides * sides)
        border =2       # Number of zero cells around the perimete

        coastline = np.ones((sides, sides), dtype=np.int)
        coastline[border:(sides-border), border:(sides-border)] = 0

        test_args = {}

        test_args['working_directory'] = \
            './../../invest-natcap.invest-3/invest_natcap/coastal_vulnerability/'
        test_args['global_polygon'] = \
            '/../../../invest-data/Base_Data/Marine/Land/global_polygon.shp'
        test_args['aoi']         = \
            '/../../../invest-data/CoastalProtection/Input/AOI_BarkClay.shp'
        test_args['cell_size']   = 250

        self.coastline = coastline
        self.sides = sides
        self.args = test_args

    def test_convert_shape_to_raster(self):
        """ Test the conversion from a shapefile to a raster """
        shapefile   = self.args['working_directory'] + \
                        self.args['global_polygon']
        aoi         = self.args['working_directory'] + \
                        self.args['aoi']
        cell_size   = self.args['cell_size']
        
        #raster = cvc.convert_shape_to_raster(shapefile,aoi, cell_size)
        
        # Load the test raster and compare it with the calculated raster
        ds = gdal.Open("./land_sea_test_raster.tif")
        band = ds.GetRasterBand(1)
        test_raster = band.ReadAsArray()

        #self.assertEquals(np.sum(np.fabs(raster - test_raster)), 0)
        pass

    def test_detect_shore(self):
        """ """
        # Should cross-check with a regression file...
        ds = gdal.Open("./test_shore_raster.tif")
        band = ds.GetRasterBand(1)
        test_shore = band.ReadAsArray()

        ds = gdal.Open("./land_sea_test_raster.tif")
        band = ds.GetRasterBand(1)
        raster = band.ReadAsArray()

        #shore = cvc.detect_shore(raster)

        #shore_filename = 'new_test_shore_raster.tif'
        #drv = gdal.GetDriverByName("GTiff")
        #ds = drv.Create(shore_filename, 
        #            shore.shape[1],
        #            shore.shape[0], 
        #            1, gdal.GDT_Float32)
        #shore_band = ds.GetRasterBand(1)
        #shore_band.SetNoDataValue(cvc.nodata())
        #shore_band.WriteArray(shore)
        #ds = None
        #drv = None

        self.assertEquals(True, True) #np.sum(np.fabs(shore - test_shore)), 0)

    def test_cast_ray(self):
        """ Test the ray-casting algorithm on an artificial test coastline
            - inputs: none
            - outputs: a ray_cast_test.tif file
            
            Description: 
                1- Takes a predefined coastline and detect the shoreline
                2- Run the marching square algorithm on each shoreline point """
        origin = np.array([ self.coastline.shape[0]/2, self.coastline.shape[1]/2])
        radius = min(self.coastline.shape)/4
        raster = self.coastline

        #dataset_size = 1000
        #dataset_size = 3 
        dataset_size = 0

        angle = np.array([random.random()*2.0*math.pi 
                            for x in range(dataset_size)])
        
        distance = np.array([random.random()*(radius-2.0) +2.0 
                            for i in range(dataset_size)])

        i = np.array(np.cos(angle)*distance).astype(int)
        j = np.array(np.sin(angle)*distance).astype(int)

        #i = np.array([0, 24, 24])
        #j = np.array([24, 3, -1])

        distance = np.sqrt(np.square(i) + np.square(j))
        
        test_data = np.array([i, j]).T
        
        should_stop_on_land = np.array([float(True) #random.choice((True, False)))
                                for i in range(test_data.shape[0])])

        direction = (test_data).astype(float)

        old_raster_val = 0

        result_data = np.empty_like(distance)

        for i in range(test_data.shape[0]):
            assert(max(np.fabs(direction[i]))) # Zero vectors not allowed

            #print(direction[i], np.sqrt(np.sum(np.square(direction[i]))))

            # If should stop on land, insert land and double maximum distance
            #print("direction:", direction[i])
            #print("max:", max(np.fabs(direction[i])))
            if should_stop_on_land[i]:
                step = direction[i] / max(np.fabs(direction[i])) # Move land...
                land = (origin + direction[i] + step)   # ...one cell further
                old_raster_val = raster[land[0]][land[1]]
                raster[land[0]][land[1]] = 1
            
            d = cvc.cast_ray(origin, direction[i], distance[i]*2.0, raster)

            result_data[i] = d

            if should_stop_on_land[i]: raster[land[0]][land[1]]=old_raster_val
 
        discrepancies = distance - result_data
        error_indices = \
            np.where(np.fabs(discrepancies)>0.000000001)[0]
       
        # Report errors
        if len(error_indices):
            #print(test_data)
            error = \
                np.sum(np.fabs(discrepancies[error_indices])) / len(error_indices)
            report_data = np.empty((len(error_indices),6), dtype=float)
            report_data[:,0:2] = test_data[error_indices]
            report_data[:,2]   = distance[error_indices]
            report_data[:,3]   = result_data[error_indices]
            report_data[:,4]   = discrepancies[error_indices]
            report_data[:,5]   = should_stop_on_land[error_indices]
            print("Entries at fault:", report_data)

        self.assertEquals(len(error_indices), 0)

    def test_compute_fetch(self):
        #direction_count = 16
        #ds = gdal.Open("./land_sea_test_raster.tif")
        #band = ds.GetRasterBand(1)
        #land_raster = band.ReadAsArray()
        #d_max = 10

        direction_count = 4 
        land_raster = np.array([[1, 1, 1, 1],\
                                [1, 0, 0, 1],\
                                [1, 1, 1, 1]]).astype('float')
        #land_raster = np.array([[1, 1, 1],\
        #                        [1, 0, 1],\
        #                        [1, 1, 1]]).astype('float')
        d_max = 1

        directions  = np.array(range(direction_count)).astype(float) *\
                        2.0 * math.pi / float(direction_count)

        print("directions:", directions)

        fetch = cvc.compute_fetch(land_raster, directions, d_max)

        #with open("fetch_test.csv", "wb") as f:
        #    for pair in zip(fetch.keys(), fetch.values()):
        #        csv.writer(f).writerow(pair)

        print("fetch", fetch)

        self.assertEquals(True, True)


    def test_coastal_vulnerability(self):
        base_dir = 'data/test_out/coastal_vulnerability_core'

        if not os.path.exists(base_dir):
            os.makedirs(base_dir)

        vi_uri = os.path.join(base_dir,'vi.tif')

        args = {}

        args['vi_uri'] = vi_uri

        cv.execute(args)

        #check correctness of output

    def tare_down(self):
        # Clean-up code here
        # Do nothing for now 
        pass
