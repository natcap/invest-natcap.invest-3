from __future__ import print_function

import unittest
import logging
import os
import subprocess
import math
import numpy as np
import random
import time
import csv

from osgeo import gdal
from osgeo import ogr
from nose.plugins.skip import SkipTest

import invest_cython_core
import invest_test_core
from invest_natcap import raster_utils
from invest_natcap.coastal_vulnerability \
    import coastal_vulnerability as cv
from invest_natcap.coastal_vulnerability \
    import coastal_vulnerability_core as cvc


LOGGER = logging.getLogger('coastal_vulnerability_test')
logging.basicConfig(format='%(asctime)s %(name)-15s %(levelname)-8s \
    %(message)s', level=logging.DEBUG, datefmt='%m/%d/%Y %H:%M:%S ')

class TestCoastalVulnerability(unittest.TestCase):
    """Main testing class for the coastal vulnerability tests"""
    
    def make_input_data(self):
        args = {}

        args['workspace_dir'] = \
        u'../../invest-natcap.invest-3/invest_natcap/coastal_vulnerability/'
        args['aoi_uri'] = os.path.join(args['workspace_dir'] + \
        u'../../../invest-data/CoastalProtection/Input/AOI_BarkClay.shp')
        args['landmass_uri'] = os.path.join(args['workspace_dir'] + \
        u'../../../invest-data/Base_Data/Marine/Land/global_polygon.shp')
        args['climatic_forcing_uri'] = os.path.join(args['workspace_dir']+\
        u'../../../invest-data/CoastalProtection/Input/WaveWatchIII.shp')
        args['bathymetry_uri'] = os.path.join(args['workspace_dir'] + \
        u'../../../invest-data/Base_Data/Marine/DEMs/claybark_dem/hdr.adf')
        args['relief_uri'] = os.path.join(args['workspace_dir'] + \
        u'../../../invest-data/Base_Data/Marine/DEMs/claybark_dem/hdr.adf')
        args['geomorphology_uri'] = os.path.join(args['workspace_dir'] + \
        u'../../../invest-data/CoastalProtection/Input/Geomorphology_BarkClay.shp')
        args['habitat_csv_uri'] = os.path.join(args['workspace_dir'] + \
        u'../../../invest-data/CoastalProtection/Input/NaturalHabitat_WCVI.csv')
        args['habitat_directory'] = os.path.join(args['workspace_dir'] + \
        u'../../../invest-data/CoastalProtection/Input/NaturalHabitat')
        args['surge_potential_uri'] = os.path.join(args['workspace_dir'] + \
        u'../../../invest-data/Base_Data/Marine/DEMs/claybark_dem/hdr.adf')
        args['sea_level_rise_uri'] = os.path.join(args['workspace_dir'] + \
        u'../../../invest-data/CoastalProtection/Input/SeaLevRise_WCVI.shp')
        args['global_population_uri'] = os.path.join(args['workspace_dir'] + \
        u'../../../invest-data/Base_Data/Marine/Population/global_pop/w001001.adf')
        args['structures'] = os.path.join(args['workspace_dir'] + \
        u'../../../invest-data/CoastalProtection/Input/Structures_BarkClay.shp')

        args['cell_size'] = 250       # cell size in meters
        args['max_fetch'] = 125000      # max fetch in meters
        args['spread_radius'] = 50    # spread in meters
        args['sector_count'] = 16       # number of equiangular sectors
        args['H_threshold'] = 10        # H threshold in km as specified in 
                                        # equ 4.8 in the user guide
        args['depth_threshold'] = 10
        args['exposure_proportion'] = 0.8   # Used to differentiate between
                                            # sheltered and exposed shoreline
        args['population_radius'] = 1000    # radius in meters within which the
                                            # population size is assessed.
        args['urban_center_threshold'] = 5000   # for the urban vulnerability 
                                                # histogram
        args['land_area_filter'] = 5000000 # Minimum landmass area. Else discard.

        return args

    def setUp(self):
        """ Set up a test coastline on which to use the marching square
        algorithm 
        
            - inputs: none (hard-coded coastline, hard-coded ray directions)
            - output: an array of (type?) 2-tuples (direction, length)
        """
        print('Generating input data...')
        self.args = self.make_input_data()

    def test_execute(self):
        cv.execute(self.args)
    
    # TODO: use adjusted_ranks when it will be accessible...
    # TODO: test limit cases
    def test_adjust_layer_ranks(self):
        one_value = np.array([[5,5,0],[5,5,0]])
        adjusted_value = cvc.adjust_layer_ranks(one_value)
        unique_value = np.unique(adjusted_value)
        assert( (unique_value.size == 2) and \
                (unique_value[0] == 0) and \
                (unique_value[1] == 3))

        two_values = np.array([[3,1,0],[3,1,0]])
        adjusted_value = cvc.adjust_layer_ranks(two_values)
        unique_value = np.unique(adjusted_value)
        assert( (unique_value.size == 3) and \
                (unique_value[0] == 0) and \
                (unique_value[1] == 3) and \
                (unique_value[2] == 4))
    
        three_values = np.array([[5,1,0],[1,2,0]])
        adjusted_value = cvc.adjust_layer_ranks(three_values)
        unique_value = np.unique(adjusted_value)
        assert( (unique_value.size == 4) and \
                (unique_value[0] == 0) and \
                (unique_value[1] == 2) and \
                (unique_value[2] == 3) and \
                (unique_value[3] == 4))

        four_values = np.array([[1,2,0],[4,3,0]])
        adjusted_value = cvc.adjust_layer_ranks(four_values)
        unique_value = np.unique(adjusted_value)
        assert( (unique_value.size == 5) and \
                (unique_value[0] == 0) and \
                (unique_value[1] == 2) and \
                (unique_value[2] == 3) and \
                (unique_value[3] == 4) and \
                (unique_value[4] == 5))
        
        return True
        
    def test_compute_vulnerability_index(self):
        cvc.compute_vulnerability_index(self.args)

    def test_compute_structure_protection(self):
        cvc.compute_structure_protection(self.args)

    def test_compute_coastal_population(self):
        cvc.compute_coastal_population(self.args)

    def test_compute_surge_potential(self):
        cvc.compute_surge_potential(self.args)

    def test_compute_sea_level_rise(self):
        cvc.compute_sea_level_rise(self.args)
        
    def test_combined_rank(self):
        def compute_combined_ranking(RankList):
            """Original equation that computes the combined habitat ranking.
                
                Input: RankList: a list of habitat ranks.
                
                Output: a combined habitat ranking. This equation is the verbose,
                unaltered python code used in the initial version of the model."""
            RankListMinus5 = [(5.0 - i) for i in RankList]
            SqRankList = [(i*i) for i in RankListMinus5]
            HabEq = \
            (1.5*max(RankListMinus5))**2+np.sum(SqRankList)-(max(RankListMinus5))**2
            rankValue = 4.8-0.5*((HabEq)**0.5)
            return rankValue

        # A few constants:
        kelp            = 4
        seagrass        = 4
        low_dune        = 3
        high_dune       = 2
        marsh           = 2
        coral           = 1
        mangrove        = 1
        coastal_forest  = 1 # If set to rank 3, we recover table in appendix B

        habitats = [[kelp],
                    [seagrass],
                    [seagrass, kelp],
                    [low_dune],
                    [coastal_forest],
                    [coastal_forest, kelp],
                    [low_dune, kelp],
                    [coastal_forest, seagrass],
                    [low_dune, seagrass],
                    [coastal_forest, kelp, seagrass],
                    [low_dune, kelp, seagrass],
                    [low_dune, coastal_forest],
                    [low_dune, coastal_forest, kelp],
                    [low_dune, coastal_forest, seagrass],
                    [low_dune, coastal_forest, kelp, seagrass],
                    [high_dune],
                    [marsh],
                    [high_dune, kelp],
                    [marsh, kelp],
                    [high_dune, seagrass],
                    [marsh, seagrass],
                    [high_dune, kelp, seagrass],
                    [high_dune, coastal_forest],
                    [high_dune, kelp, coastal_forest],
                    [marsh, coastal_forest, kelp],
                    [high_dune, seagrass, coastal_forest],
                    [marsh, coastal_forest, seagrass],
                    [high_dune, seagrass, kelp, coastal_forest],
                    [marsh, coastal_forest, kelp, seagrass],
                    [coral],
                    [mangrove],
                    [coral, seagrass],
                    [mangrove, seagrass],
                    [coral, coastal_forest],
                    [coral, low_dune],
                    [mangrove, seagrass, coastal_forest],
                    [coral, seagrass, coastal_forest],
                    [coral, seagrass, low_dune],
                    [coral, high_dune],
                    [coral, marsh],
                    [coral, seagrass, high_dune],
                    [coral, seagrass, marsh],
                    [coral, seagrass, low_dune, coastal_forest],
                    [mangrove, coral],
                    [coral, seagrass, high_dune, coastal_forest],
                    [mangrove, coral, seagrass],
                    [mangrove, coral, seagrass, coastal_forest]]
        

        ranking = np.array([compute_combined_ranking(np.array(habitats[i])) \
                            for i in range(len(habitats))])
        result = np.array([ cvc.combined_rank(np.array(habitats[i])) \
                            for i in range(len(habitats))])
        agreement = (result - ranking) < 0.001

        assert agreement.all()

    def test_compute_natural_habitats_vulnerability(self):
        cvc.compute_natural_habitats_vulnerability(self.args)

    def test_compute_geomorphology(self):
        cvc.compute_geomorphology(self.args)

    def test_compute_relief_rank(self):
        cvc.compute_relief_rank(self.args)

    def test_compute_wave_exposure(self):
        cvc.compute_wave_exposure(self.args)

    def test_compute_wind_exposure(self):
        cvc.compute_wind_exposure(self.args)

    def test_adjust_raster_to_aoi(self):
        data = self.args['DEM']
        aoi = self.args['aoi']
        cell_size = self.args['cell_size']
        intermediate_directory = self.args['intermediate_directory']
        cvc.adjust_raster_to_aoi(data, aoi, cell_size, intermediate_directory)

    def test_adjust_shapefile_to_aoi(self):
        data = self.args['unadjusted_landmass']
        aoi = self.args['aoi']
        intermediate_directory = self.args['intermediate_directory']
        cvc.adjust_shapefile_to_aoi(data, aoi, intermediate_directory)

    def test_detect_shore(self):
        """ test shore detection.
        
            inputs: none
            
            succeeds if the computed shore from the test raster is identical to
            the sample shore from the regression land file."""
        # Should cross-check with a regression file...
        ds = gdal.Open("./shore.tif")
        band = ds.GetRasterBand(1)
        test_shore = band.ReadAsArray()

        ds = gdal.Open("./landmass.tif")
        band = ds.GetRasterBand(1)
        raster = band.ReadAsArray()

        shore = cvc.detect_shore(raster)

        self.assertEquals(np.sum(np.fabs(shore - test_shore)), 0)

    def test_cast_ray(self):
        """ Test the ray-casting algorithm on an artificial test coastline
            
            inputs: none -- the coastline is generated on-the-fly
            
            Succeeds if the distances computed by the ray casting algorithm
                agree with the ones generated on-the-fly by the test.
            
            Algorithm summary:
                1- Picks random angles, distances, and stopping conditions
                    (max. distance reached or stop on land), and determine
                    where the ray casting algorithm is supposed to stop.
                2- Combine these conditions into a series of independent test
                    cases that are fed to cast_ray(), which returns a series of
                    computed distances.
                3- The computed distances are checked against the randomly 
                    generated ones to see if they agree with each other."""
        # Size of the test area 
        sides =100      # Size of the test array in cells (sides * sides)
        border =2       # Number of land cells around the perimeter

        coastline = np.ones((sides, sides), dtype=np.int) * cvc.land()
        coastline[border:(sides-border), border:(sides-border)] = cvc.sea()
        bathymetry = np.ones_like(coastline)

        # Origin is at sea, in the middle of the test area
        origin = np.array([ coastline.shape[0]/2, coastline.shape[1]/2])
        # The rays will radiate from the origin up to a maximum radius
        radius = min(coastline.shape)/4

        # Number of tests
        test_count = 1000

        # Pick random angles, distances, and stop conditions
        angle = np.array([random.random()*2.0*math.pi 
                            for x in range(test_count)])
        
        distance = np.array([random.random()*(radius-2.0) +2.0 
                            for i in range(test_count)])

        should_stop_on_land = np.array([random.choice((True, False))
                            for i in range(test_count)])

        # The angle and distance point to a location which coordinates are
        # discreet. The distance has to be recomputed to accurately reflect the
        # discreet coordinates.
        i = np.array(np.cos(angle)*distance).astype(int)
        j = np.array(np.sin(angle)*distance).astype(int)

        test_distances = np.sqrt(np.square(i) + np.square(j))
        
        # direction vectors used for the test
        direction = np.array([i, j]).T.astype(float)

        # Used to clear the land cell that triggers the stop_on_land test
        # end condition
        old_raster_val = 0

        # conpute distances using cast_ray
        computed_distances = np.empty_like(distance)
        average_depth = np.empty_like(distance)

        for i in range(direction.shape[0]):
            assert(max(np.fabs(direction[i]))) # Zero vectors not allowed
            # If should stop on land, insert land and double maximum distance
            test_distance = test_distances[i]

            if should_stop_on_land[i]:
                test_distance *= 2.0
                step = direction[i] / max(np.fabs(direction[i])) # Move land...
                land = np.around(origin + direction[i] + step)   # ...one cell further
                old_raster_val = coastline[land[0]][land[1]]
                coastline[land[0]][land[1]] = 1
            
            computed_distances[i], average_depth[i] = \
                cvc.cast_ray(origin, direction[i], test_distance, coastline, \
                bathymetry)

            if should_stop_on_land[i]:\
                coastline[land[0]][land[1]] = old_raster_val
 
        # Compute the discrepancies between test and computed distances
        discrepancies = test_distances - computed_distances
        error_indices = \
            np.where(np.fabs(discrepancies)>0.000000001)[0]
       
        self.assertEquals(len(error_indices), 0)

    def test_compute_fetch(self):
        """ Test fetch computation with random directions, max distances and
        termination conditions.
        
            args['fetch_test_raster']: raster filename used to test the
                fetch algorithm.
            args['fetch_expected_result']: comma-separated filename that
                contains the expected result of the fetch calculation.
                
            succeeds if computing fetch over 'fetch_test_raster' yields the
                same result as in 'fetch_expected_result', fails otherwise."""
        # --------------------------------------------------------------------
        # Simple test cases that can be computed by hand:
        #   1- Minimalistic: only 1 shore point, 0 fetch distances
        #   2- Non-square land raster, variable fetch distances (0 or 1)
        #   3- Variable fetch distances beyond 1
        #   4- Minimalistic island (1 point)
        #   5- Small non-trivial island (L-shaped)
        # --------------------------------------------------------------------
        d_max = 4 
        # The 4 directions in order are: left, down, right, up.
        direction_count = 4 
        
        # adjust the directions to be between 0 and 2*PI
        directions  = np.array(range(direction_count)).astype(float) *\
                        2.0 * math.pi / float(direction_count)

        #   1- Minimalistic: only 1 shore point, 0 fetch distance
        # Land is 1, water is 0
        land_raster = np.array([[1, 1, 1],\
                                [1, 0, 1],\
                                [1, 1, 1]]).astype('float')
        # Shore is water bordered by a land cell, encoded as 1. The rest is 0.
        # In this simple example, the shore is the only cell with 0, the rest
        # is not, so the shore raster is the logical inverse of land_raster
        shore_raster = (land_raster == 0).astype('float')
        # Bathymetry is set to zero, since we don't use this information yet
        bathymetry = np.zeros_like(land_raster)
        # Expected solution:
        solution = {(1, 1):(0.0, 0.0, 0.0, 0.0)}
        # compute the fetch and test equality against solution
        fetch = cvc.compute_fetch(land_raster, directions, d_max, 
            shore_raster, bathymetry)
        # Test fetch against solution
        self.assertEquals((fetch[0] == solution), True)

        #   2- Non-square land raster, variable fetch distances (0 or 1)
        land_raster = np.array([[1, 1, 1, 1],\
                                [1, 0, 0, 1],\
                                [1, 1, 1, 1]]).astype('float')
        shore_raster = (land_raster == 0).astype('float')
        bathymetry = np.zeros_like(land_raster)
        solution = {(1, 1): (0.0, 0.0, 1.0, 0.0),
                    (1, 2): (1.0, 0.0, 0.0, 0.0)}
        fetch = cvc.compute_fetch(land_raster, directions, d_max, 
            shore_raster, bathymetry)

        print('fet', fetch[0])
        print('sol', solution)
        for key in fetch[0].keys():
            print(key, fetch[0][key], 'solution', solution[key], 'equal',
            fetch[0][key]==solution[key])

        self.assertEquals((fetch[0] == solution), True)
        
        # For the third raster:
        # (1, 1): [1, 3, 0, 0]
        # (1, 2): [1, 2, 0, 1]
        # (1, 3): [1, 1, 0, 2]
        # (1, 4): [1, 0, 0, 3]
        # (2, 1): [0, 3, 1, 0]
        # (2, 2): [0, 2, 1, 1]
        # (2, 3): [0, 1, 1, 2]
        # (2, 4): [0, 0, 1, 3]
        #land_raster = np.array([[1, 1, 1, 1, 1, 1],\
        #                        [1, 0, 0, 0, 0, 1],\
        #                        [1, 0, 0, 0, 0, 1],\
        #                        [1, 1, 1, 1, 1, 1]]).astype('float')
        land_raster = np.array([[0, 0, 0, 0, 0, 0],\
                                [0, 0, 0, 0, 0, 0],\
                                [0, 1, 0, 0, 0, 0],\
                                [0, 0, 0, 0, 0, 0],\
                                [0, 0, 0, 0, 0, 0],\
                                [0, 0, 0, 0, 0, 0]]).astype('float')
        #land_raster = np.array([[0, 0, 0, 0, 0, 0],\
        #                        [0, 0, 0, 0, 0, 0],\
        #                        [0, 0, 1, 0, 0, 0],\
        #                        [0, 0, 1, 1, 0, 0],\
        #                        [0, 0, 0, 0, 0, 0],\
        #                        [0, 0, 0, 0, 0, 0]]).astype('float')
        return True 
        # -------------------------------------------------------------------- 

        #direction_count = 16

        # Load the raster file
        #ds = gdal.Open("./landmass.tif")
        #band = ds.GetRasterBand(1)
        #land_raster = band.ReadAsArray()
        #d_max = 10

        # adjust the directions to be between 0 and 2*PI
        directions  = np.array(range(direction_count)).astype(float) *\
                        2.0 * math.pi / float(direction_count)

        # compute the fetch
        fetch = cvc.compute_fetch(land_raster, directions, d_max)

        for item in fetch.items():
            print(item)

        expected_fetch = {}

        # Load the fetch regression file
        #with open("fetch.csv") as g:
        #    reader = csv.reader(g)
        #    for entry in reader:
        #        key = tuple(map(float, entry[0][1:-1].split(',')))
        #        value = tuple(map(float, entry[1][1:-1].split(',')))

        #        expected_fetch[key] = value
 
        # Test equality between computed and regression data
        self.assertEquals((fetch == expected_fetch), True)


    def test_coastal_vulnerability(self):
        """ Main test function."""
        base_dir = 'data/test_out/coastal_vulnerability_core'

        if not os.path.exists(base_dir):
            os.makedirs(base_dir)

        vi_uri = os.path.join(base_dir,'vi.tif')

        args = {}

        args['vi_uri'] = vi_uri

        cv.execute(args)

        #check correctness of output

    def tare_down(self):
        """ Clean up code."""
        # Do nothing for now 
        pass
