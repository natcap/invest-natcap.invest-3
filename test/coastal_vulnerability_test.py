from __future__ import print_function

import unittest
import logging
import os
import subprocess
import math
import numpy as np
import random
import time
import csv

from osgeo import gdal
from osgeo import ogr
from nose.plugins.skip import SkipTest

import invest_cython_core
import invest_test_core
from invest_natcap import raster_utils
from invest_natcap.coastal_vulnerability \
    import coastal_vulnerability as cv
from invest_natcap.coastal_vulnerability \
    import coastal_vulnerability_core as cvc


LOGGER = logging.getLogger('coastal_vulnerability_test')
logging.basicConfig(format='%(asctime)s %(name)-15s %(levelname)-8s \
    %(message)s', level=logging.DEBUG, datefmt='%m/%d/%Y %H:%M:%S ')

class TestCoastalVulnerability(unittest.TestCase):
    """Main testing class for the coastal vulnerability tests"""
    
    def setUp(self):
        """ Set up a test coastline on which to use the marching square
        algorithm 
        
            - inputs: none (hard-coded coastline, hard-coded ray directions)
            - output: an array of (type?) 2-tuples (direction, length)
        """

        working_directory = \
        './../../invest-natcap.invest-3/invest_natcap/coastal_vulnerability/'
        aoi_uri = os.path.join(working_directory + \
        '../../../invest-data/CoastalProtection/Input/AOI_BarkClay.shp')
        landmass_uri = os.path.join(working_directory + \
        '../../../invest-data/Base_Data/Marine/Land/global_polygon.shp')
        wind_wave_uri = os.path.join(working_directory + \
        '../../../invest-data/CoastalProtection/Input/WaveWatchIII.shp')
        DEM_uri = os.path.join(working_directory + \
        '../../../invest-data/Base_Data/Marine/DEMs/claybark_dem/hdr.adf')
        geomorphology_uri = os.path.join(working_directory + \
        '../../../invest-data/CoastalProtection/Input/Geomorphology_BarkClay.shp')
        habitat_csv_uri = os.path.join(working_directory + \
        '../../../invest-data/CoastalProtection/Input/NaturalHabitat_WCVI.csv')
        habitat_directory = os.path.join(working_directory + \
        '../../../invest-data/CoastalProtection/Input/NaturalHabitat')
        sea_level_rise_uri = os.path.join(working_directory + \
        '../../../invest-data/CoastalProtection/Input/SeaLevRise_WCVI.shp')
        global_population_uri = os.path.join(working_directory + \
        '../../../invest-data/Base_Data/Marine/Population/global_pop/w001001.adf')
        structures_uri = os.path.join(working_directory +
        '../../../invest-data/CoastalProtection/Input/Structures_BarkClay.shp')

        cell_size = 250         # cell size in meters
        max_fetch = 0250        # max fetch in meters
        spread_radius = 0250    # spread in meters
        sector_count = 16       # number of equiangular sectors
        H_threshold = 10        # H threshold in km as specified in equ 4.8 in
                                # the user guide
        population_radius = 1000    # radius in meters within which the 
                                    # population size is assessed.
        intermediate_directory = os.path.join(working_directory, 'intermediate')
        outputs_directory = os.path.join(working_directory, 'outputs')
        
        sector_range = range(sector_count)
        sectors_rad = np.array(sector_range, dtype=float) *2 *math.pi /sector_count
        sectors_deg = np.array(sector_range, dtype=int) *360 / sector_count

        # Preliminary tests...
        if not os.path.isfile(structures_uri): return False
        if not os.path.isfile(global_population_uri): return False
        # TODO: change code for the other files
        try:
            with open(wind_wave_uri):
                pass
        except IOError:
            LOGGER.debug("File %s doesn't exist." % str(wind_wave_uri))
            return False

        try:
            with open(aoi_uri):
                pass
        except IOError:
            LOGGER.debug("File %s doesn't exist." % str(aoi_uri))
            return False

        try:
            with open(landmass_uri):
                pass
        except IOError:
            LOGGER.debug("File %s doesn't exist." % str(landmass_uri))
            return False

        try:
            with open(DEM_uri):
                pass
        except IOError:
            LOGGER.debug("File %s doesn't exist." % str(DEM_uri))
            return False

        try:
            with open(geomorphology_uri):
                pass
        except IOError:
            LOGGER.debug("File %s doesn't exist." % str(geomorphology_uri))
            return False

        try:
            with open(habitat_csv_uri):
                pass
        except IOError:
            LOGGER.debug("File %s doesn't exist." % str(habitat_csv_uri))
            return False

        try:
            with open(sea_level_rise_uri):
                pass
        except IOError:
            LOGGER.debug("File %s doesn't exist." % str(sea_level_rise_uri))
            return False

        # Create intermediate directories
        if not os.path.isdir(intermediate_directory):
            os.makedirs(intermediate_directory)
        if not os.path.isdir(outputs_directory):
            os.makedirs(outputs_directory)
        # Open the files
        wind_wave_data = ogr.Open(wind_wave_uri)
        aoi = ogr.Open(aoi_uri)
        landmass = ogr.Open(landmass_uri)
        DEM = gdal.Open(DEM_uri)
        geomorphology = ogr.Open(geomorphology_uri)
        sea_level_rise = ogr.Open(sea_level_rise_uri)
        global_population = gdal.Open(global_population_uri)
        # Set to save in 'intermediate_directory'
        save_intermediate = \
            cvc.set_save_info(intermediate_directory, aoi, cell_size)
        # TODO: Split up this initialization phase into smaller chunks...
        # Adjust the wind/wave data to the aoi:
        wind_wave_data = cvc.adjust_shapefile_to_aoi(wind_wave_data, aoi, \
            intermediate_directory)
        # Convert the landmass to the right projection (aoi's)
        adjusted_landmass =cvc.adjust_shapefile_to_aoi(landmass,aoi, \
            intermediate_directory)
        # Extract the AOI and the landmasses as arrays
        aoi_array = cvc.array_from_shapefile(aoi, aoi, cell_size)
        land_array = cvc.array_from_shapefile(adjusted_landmass, aoi, cell_size)
        # Use the arrays to construct the shore data
        land_array[land_array == 0] = cvc.sea()
        land_array[aoi_array == 0] = cvc.nodata()
        # compute the fetch
        print('computing fetch...')
        fetch = cvc.compute_fetch(land_array, sectors_rad, max_fetch)
        print('done.')
        # Compute the shoreline
        shore_array = cvc.detect_shore(land_array)
        shore_path = save_intermediate(shore_array, 'shore.tif') 
        shore = gdal.Open(shore_path)
        test_args = {}

        test_args['intermediate_directory'] = intermediate_directory
        test_args['outputs_directory'] = outputs_directory
        test_args['wind_wave_data'] = wind_wave_data
        test_args['aoi'] = aoi
        test_args['landmass'] = adjusted_landmass
        test_args['unadjusted_landmass'] = landmass
        test_args['DEM'] = DEM
        test_args['geomorphology'] = geomorphology
        test_args['cell_size'] = cell_size
        test_args['fetch'] = fetch
        test_args['shore'] = shore
        test_args['H_threshold'] = H_threshold
        test_args['sector_count'] = sector_count
        test_args['spread_radius'] = spread_radius
        test_args['habitat_csv'] = habitat_csv_uri
        test_args['habitat_directory'] = habitat_directory
        test_args['sea_level_rise'] = sea_level_rise
        test_args['spread_radius'] = spread_radius
        test_args['global_population'] = global_population
        test_args['population_radius'] = population_radius
        test_args['structures'] = structures_uri

        self.args = test_args

    def test_compute_vulnerability_index(self):
        cvc.compute_vulnerability_index(self.args)

    def test_compute_structure_protection(self):
        cvc.compute_structure_protection(self.args)

    def test_compute_coastal_population(self):
        cvc.compute_coastal_population(self.args)

    def test_compute_surge_potential(self):
        cvc.compute_surge_potential(self.args)

    def test_compute_sea_level_rise(self):
        cvc.compute_sea_level_rise(self.args)
        
    def test_combined_rank(self):
        def compute_combined_ranking(RankList):
            """Original equation that computes the combined habitat ranking.
                
                Input: RankList: a list of habitat ranks.
                
                Output: a combined habitat ranking. This equation is the verbose,
                unaltered python code used in the initial version of the model."""
            RankListMinus5 = [(5.0 - i) for i in RankList]
            SqRankList = [(i*i) for i in RankListMinus5]
            HabEq = \
            (1.5*max(RankListMinus5))**2+np.sum(SqRankList)-(max(RankListMinus5))**2
            rankValue = 4.8-0.5*((HabEq)**0.5)
            return rankValue

        # A few constants:
        kelp            = 4
        seagrass        = 4
        low_dune        = 3
        high_dune       = 2
        marsh           = 2
        coral           = 1
        mangrove        = 1
        coastal_forest  = 1 # If set to rank 3, we recover table in appendix B

        habitats = [[kelp],
                    [seagrass],
                    [seagrass, kelp],
                    [low_dune],
                    [coastal_forest],
                    [coastal_forest, kelp],
                    [low_dune, kelp],
                    [coastal_forest, seagrass],
                    [low_dune, seagrass],
                    [coastal_forest, kelp, seagrass],
                    [low_dune, kelp, seagrass],
                    [low_dune, coastal_forest],
                    [low_dune, coastal_forest, kelp],
                    [low_dune, coastal_forest, seagrass],
                    [low_dune, coastal_forest, kelp, seagrass],
                    [high_dune],
                    [marsh],
                    [high_dune, kelp],
                    [marsh, kelp],
                    [high_dune, seagrass],
                    [marsh, seagrass],
                    [high_dune, kelp, seagrass],
                    [high_dune, coastal_forest],
                    [high_dune, kelp, coastal_forest],
                    [marsh, coastal_forest, kelp],
                    [high_dune, seagrass, coastal_forest],
                    [marsh, coastal_forest, seagrass],
                    [high_dune, seagrass, kelp, coastal_forest],
                    [marsh, coastal_forest, kelp, seagrass],
                    [coral],
                    [mangrove],
                    [coral, seagrass],
                    [mangrove, seagrass],
                    [coral, coastal_forest],
                    [coral, low_dune],
                    [mangrove, seagrass, coastal_forest],
                    [coral, seagrass, coastal_forest],
                    [coral, seagrass, low_dune],
                    [coral, high_dune],
                    [coral, marsh],
                    [coral, seagrass, high_dune],
                    [coral, seagrass, marsh],
                    [coral, seagrass, low_dune, coastal_forest],
                    [mangrove, coral],
                    [coral, seagrass, high_dune, coastal_forest],
                    [mangrove, coral, seagrass],
                    [mangrove, coral, seagrass, coastal_forest]]
        

        ranking = np.array([compute_combined_ranking(np.array(habitats[i])) \
                            for i in range(len(habitats))])
        result = np.array([ cvc.combined_rank(np.array(habitats[i])) \
                            for i in range(len(habitats))])
        agreement = (result - ranking) < 0.001

        assert agreement.all()

    def test_compute_natural_habitats_vulnerability(self):
        cvc.compute_natural_habitats_vulnerability(self.args)

    def test_compute_geomorphology(self):
        cvc.compute_geomorphology(self.args)

    def test_compute_relief_rank(self):
        cvc.compute_relief_rank(self.args)

    def test_compute_wave_exposure(self):
        cvc.compute_wave_exposure(self.args)

    def test_compute_wind_exposure(self):
        cvc.compute_wind_exposure(self.args)

    def test_adjust_raster_to_aoi(self):
        data = self.args['DEM']
        aoi = self.args['aoi']
        cell_size = self.args['cell_size']
        intermediate_directory = self.args['intermediate_directory']
        cvc.adjust_raster_to_aoi(data, aoi, cell_size, intermediate_directory)

    def test_adjust_shapefile_to_aoi(self):
        data = self.args['unadjusted_landmass']
        aoi = self.args['aoi']
        intermediate_directory = self.args['intermediate_directory']
        cvc.adjust_shapefile_to_aoi(data, aoi, intermediate_directory)

    def test_detect_shore(self):
        """ test shore detection.
        
            inputs: none
            
            succeeds if the computed shore from the test raster is identical to
            the sample shore from the regression land file."""
        # Should cross-check with a regression file...
        ds = gdal.Open("./shore.tif")
        band = ds.GetRasterBand(1)
        test_shore = band.ReadAsArray()

        ds = gdal.Open("./landmass.tif")
        band = ds.GetRasterBand(1)
        raster = band.ReadAsArray()

        shore = cvc.detect_shore(raster)

        self.assertEquals(np.sum(np.fabs(shore - test_shore)), 0)

    def test_cast_ray(self):
        """ Test the ray-casting algorithm on an artificial test coastline
            
            inputs: none -- the coastline is generated on-the-fly
            
            Succeeds if the distances computed by the ray casting algorithm
                agree with the ones generated on-the-fly by the test.
            
            Algorithm summary:
                1- Picks random angles, distances, and stopping conditions
                    (max. distance reached or stop on land), and determine
                    where the ray casting algorithm is supposed to stop.
                2- Combine these conditions into a series of independent test
                    cases that are fed to cast_ray(), which returns a series of
                    computed distances.
                3- The computed distances are checked against the randomly 
                    generated ones to see if they agree with each other."""
        # Size of the test area 
        sides =100      # Size of the test array in cells (sides * sides)
        border =2       # Number of land cells around the perimeter

        coastline = np.ones((sides, sides), dtype=np.int) * cvc.land()
        coastline[border:(sides-border), border:(sides-border)] = cvc.sea()

        # Origin is at sea, in the middle of the test area
        origin = np.array([ coastline.shape[0]/2, coastline.shape[1]/2])
        # The rays will radiate from the origin up to a maximum radius
        radius = min(coastline.shape)/4

        # Number of tests
        test_count = 1000

        # Pick random angles, distances, and stop conditions
        angle = np.array([random.random()*2.0*math.pi 
                            for x in range(test_count)])
        
        distance = np.array([random.random()*(radius-2.0) +2.0 
                            for i in range(test_count)])

        should_stop_on_land = np.array([random.choice((True, False))
                            for i in range(test_count)])

        # The angle and distance point to a location which coordinates are
        # discreet. The distance has to be recomputed to accurately reflect the
        # discreet coordinates.
        i = np.array(np.cos(angle)*distance).astype(int)
        j = np.array(np.sin(angle)*distance).astype(int)

        test_distances = np.sqrt(np.square(i) + np.square(j))
        
        # direction vectors used for the test
        direction = np.array([i, j]).T.astype(float)

        # Used to clear the land cell that triggers the stop_on_land test
        # end condition
        old_raster_val = 0

        # conpute distances using cast_ray
        computed_distances = np.empty_like(distance)

        for i in range(direction.shape[0]):
            assert(max(np.fabs(direction[i]))) # Zero vectors not allowed
            # If should stop on land, insert land and double maximum distance
            test_distance = test_distances[i]

            if should_stop_on_land[i]:
                test_distance *= 2.0
                step = direction[i] / max(np.fabs(direction[i])) # Move land...
                land = np.around(origin + direction[i] + step)   # ...one cell further
                old_raster_val = coastline[land[0]][land[1]]
                coastline[land[0]][land[1]] = 1
            
            computed_distances[i] = \
                cvc.cast_ray(origin, direction[i], test_distance, coastline)

            if should_stop_on_land[i]:\
                coastline[land[0]][land[1]] = old_raster_val
 
        # Compute the discrepancies between test and computed distances
        discrepancies = test_distances - computed_distances
        error_indices = \
            np.where(np.fabs(discrepancies)>0.000000001)[0]
       
        self.assertEquals(len(error_indices), 0)

    def test_compute_fetch(self):
        """ Test fetch computation with random directions, max distances and
        termination conditions.
        
            args['fetch_test_raster']: raster filename used to test the
                fetch algorithm.
            args['fetch_expected_result']: comma-separated filename that
                contains the expected result of the fetch calculation.
                
            succeeds if computing fetch over 'fetch_test_raster' yields the
                same result as in 'fetch_expected_result', fails otherwise."""
        # --------------------------------------------------------------------
        # Simple test cases that can be computed by hand
        # --------------------------------------------------------------------
        d_max = 4 
        direction_count = 4 
        #
        # With the above parameters, computing fetch on the fo 1st raster 
        # should yield: (1, 1): [0, 0, 0, 0]
        #land_raster = np.array([[1, 1, 1],\
        #                        [1, 0, 1],\
        #                        [1, 1, 1]]).astype('float')
        #
        # For the second raster: 
        # (1, 1): [0, 1, 0, 0]
        # (1, 2): [0, 0, 0, 1]
        #land_raster = np.array([[1, 1, 1, 1],\
        #                        [1, 0, 0, 1],\
        #                        [1, 1, 1, 1]]).astype('float')
        #
        # For the third raster:
        # (1, 1): [1, 3, 0, 0]
        # (1, 2): [1, 2, 0, 1]
        # (1, 3): [1, 1, 0, 2]
        # (1, 4): [1, 0, 0, 3]
        # (2, 1): [0, 3, 1, 0]
        # (2, 2): [0, 2, 1, 1]
        # (2, 3): [0, 1, 1, 2]
        # (2, 4): [0, 0, 1, 3]
        #land_raster = np.array([[1, 1, 1, 1, 1, 1],\
        #                        [1, 0, 0, 0, 0, 1],\
        #                        [1, 0, 0, 0, 0, 1],\
        #                        [1, 1, 1, 1, 1, 1]]).astype('float')
        land_raster = np.array([[0, 0, 0, 0, 0, 0],\
                                [0, 0, 0, 0, 0, 0],\
                                [0, 1, 0, 0, 0, 0],\
                                [0, 0, 0, 0, 0, 0],\
                                [0, 0, 0, 0, 0, 0],\
                                [0, 0, 0, 0, 0, 0]]).astype('float')
        #land_raster = np.array([[0, 0, 0, 0, 0, 0],\
        #                        [0, 0, 0, 0, 0, 0],\
        #                        [0, 0, 1, 0, 0, 0],\
        #                        [0, 0, 1, 1, 0, 0],\
        #                        [0, 0, 0, 0, 0, 0],\
        #                        [0, 0, 0, 0, 0, 0]]).astype('float')
        # -------------------------------------------------------------------- 

        #direction_count = 16

        # Load the raster file
        #ds = gdal.Open("./landmass.tif")
        #band = ds.GetRasterBand(1)
        #land_raster = band.ReadAsArray()
        #d_max = 10

        # adjust the directions to be between 0 and 2*PI
        directions  = np.array(range(direction_count)).astype(float) *\
                        2.0 * math.pi / float(direction_count)

        # compute the fetch
        fetch = cvc.compute_fetch(land_raster, directions, d_max)

        for item in fetch.items():
            print(item)

        expected_fetch = {}

        # Load the fetch regression file
        #with open("fetch.csv") as g:
        #    reader = csv.reader(g)
        #    for entry in reader:
        #        key = tuple(map(float, entry[0][1:-1].split(',')))
        #        value = tuple(map(float, entry[1][1:-1].split(',')))

        #        expected_fetch[key] = value
 
        # Test equality between computed and regression data
        self.assertEquals((fetch == expected_fetch), True)


    def test_coastal_vulnerability(self):
        """ Main test function."""
        base_dir = 'data/test_out/coastal_vulnerability_core'

        if not os.path.exists(base_dir):
            os.makedirs(base_dir)

        vi_uri = os.path.join(base_dir,'vi.tif')

        args = {}

        args['vi_uri'] = vi_uri

        cv.execute(args)

        #check correctness of output

    def tare_down(self):
        """ Clean up code."""
        # Do nothing for now 
        pass
