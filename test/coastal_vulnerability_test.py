from __future__ import print_function

import unittest
import logging
import os
import subprocess

from osgeo import gdal
from nose.plugins.skip import SkipTest
import math
import numpy as np
import random
import time

from invest_natcap.coastal_vulnerability import coastal_vulnerability
from invest_natcap.coastal_vulnerability import coastal_vulnerability_core
import invest_cython_core
import invest_test_core


LOGGER = logging.getLogger('coastal_vulnerability_test')
logging.basicConfig(format='%(asctime)s %(name)-15s %(levelname)-8s \
    %(message)s', level=logging.DEBUG, datefmt='%m/%d/%Y %H:%M:%S ')

class TestCoastalVulnerability(unittest.TestCase):
    """Main testing class for the coastal vulnerability tests"""
    
    def setUp(self):
        """ Set up a test coastline on which to use the marching square
        algorithm 
        
            - inputs: none (hard-coded coastline, hard-coded ray directions)
            - output: an array of (type?) 2-tuples (direction, length)
        """

        sides =100       # Size of the array in cells (sides * sides)
        border =2       # Number of zero cells around the perimete

        coastline = np.ones((sides, sides), dtype=np.int)
        coastline[border:(sides-border), border:(sides-border)] = 0

        test_args = {}

        test_args['working_directory'] = \
            './../../invest-natcap.invest-3/invest_natcap/coastal_vulnerability/'
        test_args['global_polygon'] = \
            '/../../../invest-data/Base_Data/Marine/Land/global_polygon.shp'
        test_args['aoi']         = \
            '/../../../invest-data/CoastalProtection/Input/AOI_BarkClay.shp'
        test_args['cell_size']   = 250

        self.coastline = coastline
        self.sides = sides
        self.args = test_args

    def test_convert_shape_to_raster(self):
        shapefile   = self.args['working_directory'] + \
                        self.args['global_polygon']
        aoi         = self.args['working_directory'] + \
                        self.args['aoi']
        cell_size   = self.args['cell_size']
        
        raster =\
            coastal_vulnerability_core.convert_shape_to_raster(
                shapefile,aoi, cell_size)
        
        # Load the test raster and compare it with the calculated raster
        ds = gdal.Open("./land_sea_test_raster.tif")
        band = ds.GetRasterBand(1)
        test_raster = band.ReadAsArray()

        self.assertEquals(np.sum(np.fabs(raster - test_raster)), 0)

    def test_detect_shore(self):
        """ """
        ds = gdal.Open("./land_sea_test_raster.tif")
        band = ds.GetRasterBand(1)
        raster = band.ReadAsArray()

        shore=coastal_vulnerability_core.detect_shore(raster)

        # Should cross-check with a regression file...
        ds = gdal.Open("./shore_test_raster.tif")
        band = ds.GetRasterBand(1)
        test_shore = band.ReadAsArray()

        self.assertEquals(np.sum(np.fabs(shore - test_shore)), 0)

    def test_cast_rays(self):
        """ Test the ray-casting algorithm on an artificial test coastline
            - inputs: none
            - outputs: a ray_cast_test.tif file
            
            Description: 
                1- Takes a predefined coastline and detect the shoreline
                2- Run the marching square algorithm on each shoreline point """
        origin = np.array([ self.coastline.shape[0]/2, self.coastline.shape[1]/2])
        radius = min(self.coastline.shape)/4
        raster = self.coastline

        dataset_size = 1000

        angle = np.array([random.random()*2.0*math.pi 
                            for x in range(dataset_size)])
        
        distance = (random.random()-0.5)*2.0*(radius-2) +2

        i = np.array(np.cos(angle)*distance).astype(int)
        j = np.array(np.sin(angle)*distance).astype(int)

        distance = np.sqrt(np.square(i) + np.square(j))
        
        test_data = np.array([i, j]).T
        
        should_stop_on_land = np.array([float(random.choice((True, False)))
                                for i in range(test_data.shape[0])])

        direction = (test_data).astype(float)

        old_raster_val = 0

        result_data = np.empty_like(distance)

        for i in range(test_data.shape[0]):
            direction[i] #/= distance[i] #max(np.fabs(direction)) 

            #print(direction[i], np.sqrt(np.sum(np.square(direction[i]))))

            # If should stop on land, insert land and double maximum distance
            if should_stop_on_land[i]:
                distance[i] *= 2.0
                land = (direction[i] / max(np.fabs(direction[i]))) + test_data[i]
                old_raster_val = raster[land[0]][land[1]]
                raster[land[0]][land[1]] = 1
            
            result_data[i] = coastal_vulnerability_core.cast_ray(origin, direction[i], distance[i], raster)

            if should_stop_on_land[i]: raster[land[0]][land[1]]=old_raster_val
 
        discrepancies = distance - result_data
        error_indices = \
            np.where(np.fabs(discrepancies)>0.000000001)[0]
       
        # Report errors
        if len(error_indices):
            #print(test_data)
            error = \
                np.sum(np.fabs(discrepancies[error_indices])) / len(error_indices)
            report_data = np.empty((len(error_indices),7), dtype=float)
            report_data[:,0:2] = test_data[error_indices]
            report_data[:,2:4] = direction[error_indices]
            report_data[:,4]   = result_data[error_indices]
            report_data[:,5]   = should_stop_on_land[error_indices]
            report_data[:,6] = discrepancies[error_indices]
            print("Entries at fault:", report_data)

        self.assertEquals(len(error_indices), 0)

    def test_compute_fetch(self):
        ds = gdal.Open("./land_sea_test_raster.tif")
        band = ds.GetRasterBand(1)
        land_raster = band.ReadAsArray()
        directions  = np.array([0, 1, 2, 3, 4, 5, 6, 7]).astype(float) * 2*math.pi/8

        d_max = 10

        coastal_vulnerability_core.compute_fetch(land_raster, directions, d_max)

        self.assertEquals(True, True)


    def test_coastal_vulnerability(self):
        base_dir = 'data/test_out/coastal_vulnerability_core'

        if not os.path.exists(base_dir):
            os.makedirs(base_dir)

        vi_uri = os.path.join(base_dir,'vi.tif')

        args = {}

        args['vi_uri'] = vi_uri

        coastal_vulnerability.execute(args)

        #check correctness of output

    def tare_down(self):
        # Clean-up code here
        # Do nothing for now 
        pass
